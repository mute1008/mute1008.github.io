+++
title = "EarnHub Exploit"
date = "2022-05-19"
tags = [
    "security",
]
draft = true
+++

#### EarnHubでの事例

EarnHubにどういう機能があったのか - makeHop関数

ガス効率良く、異なるステーキングプールで資金を移動させることが出来るらしい

引数で受け取ったコントラクトアドレスをapproveしてしまう

そのため、コントラクトトークンに引き出し用関数を用意しておけば、好きに引き出せちゃうのか

対象のURL
https://bscscan.com/address/0x63bdbea2fec57896091019bbe887a35e6dc229bd#code

URL
https://miro.medium.com/max/1400/1*v8vH2iVkw4hHq9NDJlRkDA.png

- HardHatの準備をする
- ContractAを用意する
- ContractBを用意する
- デプロイする

```solidity
function makeHop(IStaking _newPool) external override {
    // senderのsharesが0以上であること
    // TODO: sharesに何が入ってる？
    require(shares[msg.sender].amount > 0, 'Not enough in stake to hop');

    // sharesの量を取得
    uint256 amt = shares[msg.sender].amount;

    // ネイティブトークン報酬を支払う
    if (getUnpaidEarnings(msg.sender) > 0) {
        giveStakingReward(msg.sender);
    }

    // sharesから削除
    _removeShares(amt, msg.sender);

    // approveする
    // ここが問題になっているところっぽい
    tokenPool.stakingToken.approve(address(_newPool), tokenPool.stakingToken.totalSupply()); // ! ERROR HERE

    // reverseHopする？
    _newPool.receiveHop(amt, msg.sender, payable(address(this)));
}

function receiveHop(uint256 _amt, address _addr, address payable _oldPool) external override authorized {
    require(tokenPool.stakingToken.allowance(_oldPool, address(this)) >= _amt, 'Not enough allowance');

    _enterStaking(_addr, _amt, _oldPool);
}
```

The logic error was in the makeHop() function.

The makeHop function allowed shareholders to shift their funds through different staking pools in a gas-efficient manner. This feature was intended to be implemented on the next dApp update, however, it’s been around for about 1 month on the contract side.

```solidity
function makeHop(IStaking _newPool) external override {
    require(shares[msg.sender].amount > 0, 'Not enough in stake to hop');
    uint256 amt = shares[msg.sender].amount;
    // Pay native token rewards.
    if (getUnpaidEarnings(msg.sender) > 0) {
        giveStakingReward(msg.sender);
    }
    _removeShares(amt, msg.sender);
    tokenPool.stakingToken.approve(address(_newPool), tokenPool.stakingToken.totalSupply()); // ! ERROR HERE
    _newPool.receiveHop(amt, msg.sender, payable(address(this)));
}

function receiveHop(uint256 _amt, address _addr, address payable _oldPool) external override authorized {
    require(tokenPool.stakingToken.allowance(_oldPool, address(this)) >= _amt, 'Not enough allowance');

    _enterStaking(_addr, _amt, _oldPool);
}
```

The issue is in the line showcased below, which assumes that there can not be a malicious smart contract on the pool that is called on receiveHop(_pool).

tokenPool.stakingToken.approve(address(_newPool), tokenPool.stakingToken.totalSupply());
By approving the totalSupply to the new pool, Contract B was able to have allowance to spend the staking contract tokens. This basically means they were able to withdraw them from the staking contract at whim once that initial setup was made.


```
The attacker created contract A
The attacker created contract B, the “leecher” contract.
The attacker contract then proceeded to buy some EarnHub, stake it, and make it hop to the leecher contract. (makeHop(contractBaddress))
After receiving the hop, the contract was able to drain the funds from the staking contract by just using the transferFrom() function repeated times.
```

#### どう修正するべきか
