[{"categories":null,"contents":"RPOとは、Gareth Heyesが提唱した脆弱性です。(http://www.thespanner.co.uk/2014/03/21/rpo/)\nこの脆弱性の理解のため、今回はintigritiのXSS Challengeで出題された問題の再現を行います。 この問題の詳細は以下の動画で確認できます。\n 上記の動画では、http://vulnerable-server//example.com/..にアクセスを行い、相対パスで読み込んでいるリソースの起点をhttp://vulnerable-server//example.comとすることで、任意のスクリプトの実行を行なっています。\nhttp://vulnerable-server//example.com/..へのアクセスは、サーバーの仕様によりhttp://vulnerable-server/にアクセスした時と同じコンテンツが返却されます。\nhttp://vulnerable-server/では、以下の様に相対パスでのスクリプトの読み込みを行なっているため、http://vulnerable-server//example.com/script.jsからスクリプトが読み込まれます。\n1  \u0026lt;script src=script.js\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;!-- http://vulnerable-server//example.com/script.js--\u0026gt;   http://vulnerable-server//example.com/script.jsへのアクセスは、リダイレクトの機能が動作するため、実際にはhttp://example.com/script.jsから読み込まれます。\n攻撃者はexample.comの部分を好きなドメインに書き換えてアクセスすることで、好きなドメインからスクリプトを読み込むことが可能になります。\n実装してみる 今回実装する脆弱なWebサーバーは、以下の機能を有しています。\n //\u0026lt;ホスト名\u0026gt;というようなアクセスでリダイレクトが可能  ex. http://vulnerable-server//example.com   正規化されたパスのコンテンツが返却される  ex. http://example.com/first/.. =\u0026gt; http://example.com/   相対パスでスクリプトの読み込みが行われている  ex. \u0026lt;script src=script.js\u0026gt;\u0026lt;/script\u0026gt;    Webサーバーの実装は以下の通りです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package main import ( \u0026#34;net/http\u0026#34; \u0026#34;log\u0026#34; \u0026#34;path\u0026#34; \u0026#34;fmt\u0026#34; ) type VulnerableHandler map[string]http.Handler func (v VulnerableHandler) ServeHTTP(w http.ResponseWriter,r *http.Request){ // Serve HTTP \tp := path.Clean(r.URL.Path) if h, ok := v[p]; ok { log.Printf(\u0026#34;serve: %s\\n\u0026#34;, p) h.ServeHTTP(w, r) return } // OpenRedirect \tif len(r.URL.Path) \u0026gt; 1 \u0026amp;\u0026amp; r.URL.Path[0] == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; r.URL.Path[1] == \u0026#39;/\u0026#39; { redirectTo := fmt.Sprintf(\u0026#34;https://%s\u0026#34;, r.URL.Path[2:]) w.Header().Set(\u0026#34;Location\u0026#34;, redirectTo) w.WriteHeader(302) log.Printf(\u0026#34;redirect: %s\\n\u0026#34;, redirectTo) return } // return 404 \thttp.Error(w, \u0026#34;404\u0026#34;, http.StatusNotFound) } func index(w http.ResponseWriter, r *http.Request) { w.Write([]byte(` \u0026lt;p\u0026gt;index page\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; `)) } func main() { mux := http.NewServeMux() mux.Handle(\u0026#34;/\u0026#34;, VulnerableHandler{ \u0026#34;/\u0026#34;: http.HandlerFunc(index), }) handler := VulnerableHandler{ \u0026#34;/\u0026#34;: http.HandlerFunc(index), } http.ListenAndServe(\u0026#34;:8000\u0026#34;, handler) }   GitHubのリンクはこちらです。(https://github.com/mute1997/relative-path-overwrite)\n再現 実装したサーバーを用いて、XSSを再現させます。\nまずChromeでhttp://localhost:8000//example.com/..にアクセスしますが、ここで問題があります。\n以下のスクリーンショットの様に、Chromeではhttp://localhost:8000//example.com/..にアクセスした場合、ブラウザによってhttp://localhost:8000へのアクセスへ勝手に変更されてしまいます。\nこの挙動は、FireFoxはSafariでも同様です。 これでは、相対パスの起点をhttp://localhost:8000//example.comにすることが出来ません。\nしかし、FireFoxではhttp://localhost:8000//example.com/%2e%2eと言う様なアクセスを行うことで、ブラウザの正規化を回避してアクセスが可能になります。\nFireFoxでhttp://localhost:8000//example.com/%2e%2eにアクセスすることで、以下の様にhttp://example.com/script.jsからファイルを読み込んでおり、攻撃が成功したことがわかります。\nまとめ 今回の例では、非常に限定的ではありますが、RPOとOpenRedirectを用いてXSSが可能であることを確認できました。 相対パスの読み込みを絶対パスに修正するだけで回避可能な脆弱性なため、リソースの読み込みは必要が無ければ絶対URLで行うのが良さそうです。\n","date":"Jul 20","permalink":"https://mute1997.github.io/post/2021-07-21-rpo/","tags":["security"],"title":"RPOとOpenRedirectを用いたXSS"},{"categories":null,"contents":"prototype pollutionについて調べていたところ、単純なパターンであれば自動で検知出来るのではと考えたので実際に実装してみることにしました。\nprototype pollutionとは JavaScriptでは、オブジェクトのプロパティにアクセスを試みた際、プロトタイプをたどり、nullに到達するまで探索が続きます。 これはプロトタイプチェーンと呼ばれます。\n例として以下のようなコードを考えます。\n1 2 3 4 5 6 7 8  const a = {\u0026#39;p\u0026#39;: 1} const b = Object.create(a) // bにプロパティはない console.log(b) // {}  // aまで探索され、1と表示される console.log(b.p) // 1   JavaScriptでは、上記のような挙動を実現するために、各オブジェクトは__proto__プロパティを保持しており、これは他オブジェクトへリンクされています。\n1  console.log(b.__proto__ == a) // true   一般的なオブジェクトであれば、__proto__プロパティはObject.prototypeにリンクされています。\n1  console.log(({}).__proto__ == Object.prototype) // true   そのため、Object.prototypeのプロパティを上書きすることが出来れば、各オブジェクトに任意のプロパティを生やすことができます。これはprototype pollutionと呼ばれています。\nこのようなObject.prototypeを上書きするような挙動は、以下のようなオブジェクトをコピーするコードで発生することがあります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function merge(a, b) { for (let key in b) { if (isObject(a[key]) \u0026amp;\u0026amp; isObject(b[key])) { merge(a[key], b[key]); } else { a[key] = b[key]; } } return a; }   1 2 3 4  const obj1 = {} const obj2 = JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;: {\u0026#34;polluted\u0026#34;: 1}}\u0026#39;) merge(obj1, obj2) console.log(Object.prototype.polluted) // == 1   先ほど説明したように、一般的なオブジェクトであれば__proto__はObject.prototypeを指すため、__proto__というキーを含むオブジェクトをコピーすると、Object.prototypeを上書きしてしまいます。\n今回は、このような\u0026lt;関数名\u0026gt;(\u0026lt;コピー先\u0026gt;, \u0026lt;コピー元\u0026gt;)というような関数を検知するコードを書くことを目標とします。\n以下は今回のスキャナでの検知を目的としたコードです。\nhttps://github.com/mute1997/prototype-pollution\nprototype pollutionを見つける 基本方針として、\n コード内のすべての関数定義の取り出し __proto__というキーを含むオブジェクトを引数に指定して関数呼び出し 関数呼び出し後にObject.prototypeが上書きされているか確認  という方法で確認していきます。\n構文解析にはesprimaを利用し、ASTを辿っていくのにestraverseを利用しました。\n以下が検出部分のコードです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  estraverse.traverse(ast, { enter: function (node, _parent) { if (node.type !== esprima.Syntax.FunctionDeclaration) { return } try { let payload = esprima.parse(`JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;:{\u0026#34;polluted\u0026#34;:1}}\u0026#39;)`).body[0].expression let arg = esprima.parse(\u0026#39;({})\u0026#39;).body[0].expression let args = node.params.map((_param, idx) =\u0026gt; { return _.cloneDeep(node.params).map((_args, i) =\u0026gt; idx == i ? payload : arg) }) args.forEach((arg) =\u0026gt; { let declaration = escodegen.generate(node) let call = escodegen.generate({ type: esprima.Syntax.ExpressionStatement, expression: { type: esprima.Syntax.CallExpression, callee: { type: esprima.Syntax.Identifier, name: node.id.name }, arguments: arg } }) let detection = ` if (Object.prototype.polluted == 1) { console.log(\\`detected! ${call}\\`) delete Object.prototype.polluted } ` eval(declaration) eval(call) eval(detection) }) } catch (e) { console.log(e) } } })   上記のコードは、merge関数に対して以下のパターンを試します。\n1 2  merge({}, JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;:{\u0026#34;polluted\u0026#34;:1}}\u0026#39;)) merge(JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;:{\u0026#34;polluted\u0026#34;:1}}\u0026#39;), {})   実行すると、merge({}, JSON.parse('{\u0026quot;__proto__\u0026quot;:{\u0026quot;polluted\u0026quot;:1}}')) のパターンが脆弱であると検出されていることが分かります。\n1 2 3 4 5 6 7 8 9 10  [~/ppfinder]$ npm start \u0026gt; ppfinder@1.0.0 start /home/mute/ppfinder \u0026gt; node index.js [ppfinder] git clone https://github.com/mute1997/prototype-pollution [ppfinder] command failed: git clone https://github.com/mute1997/prototype-pollution [ppfinder] npm install: ./prototype-pollution detected! merge({}, JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;:{\u0026#34;polluted\u0026#34;:1}}\u0026#39;)); finish https://github.com/mute1997/prototype-pollution   以下が今回、検出に利用したコードベースです。\n https://github.com/mute1997/find-prototype-pollution  今後の作業 この実装では、テストする関数内で別の関数の呼び出しがあった際にうまく動作しないため、修正が必要です。\nさらに、引数に{\u0026quot;__proto__\u0026quot;:{\u0026quot;polluted\u0026quot;:1}}を渡すタイプしか検知が出来ないため、他パターンへの対応が必要です。\n","date":"Jun 23","permalink":"https://mute1997.github.io/post/2021-06-23-prototype-pollution/","tags":["security"],"title":"prototype pollutionを自動で見つける"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://mute1997.github.io/articles/","tags":null,"title":"Articles"},{"categories":null,"contents":"以下の記事を読んでいて気になったことがあるので調べてみた。\nhttps://portswigger.net/web-security/cross-site-scripting/preventing#encode-data-on-output\n気になったのは以下の部分。\n1 2 3  Sometimes you\u0026#39;ll need to apply multiple layers of encoding, in the correct order. For example, to safely embed user input inside an event handler, you need to deal with both the JavaScript context and the HTML context. So you need to first Unicode-escape the input, and then HTML-encode it: \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;This string needs two layers of escaping\u0026#39;\u0026#34;\u0026gt;test\u0026lt;/a\u0026gt;   イベントハンドラにJavaScriptを書いている所にユーザーの入力を埋め込む場合は、unicodeエスケープをしてからHTMLエンコードする必要があると書いてある。\n個人的にはunicodeエスケープだけではダメなのか気になったので実験してみた。\nアラートを実行するために';alert(1);'を入力したことを考える。\n以下がunicodeエスケープのみを行って埋め込んだ場合。\n1  \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;\u0026amp;#x0027;\u0026amp;#x003b;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003b;\u0026amp;#x0027;\u0026#39;;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;   以下はunicodeエスケープした後にHTMLエンコードを行ったもの。\n1  \u0026lt;a href=\u0026#34;#\u0026#34; onclick=\u0026#34;x=\u0026#39;\u0026amp;#38;\u0026amp;#35;x0027\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x003b\u0026amp;#59;alert\u0026amp;#38;\u0026amp;#35;x0028\u0026amp;#59;1\u0026amp;#38;\u0026amp;#35;x0029\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x003b\u0026amp;#59;\u0026amp;#38;\u0026amp;#35;x0027\u0026amp;#59;\u0026#39;;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;   unicodeエスケープとHTMLエンコードには以下の関数を用いた。\n1 2 3 4 5  function htmlEncode(str){ return String(str).replace(/[^\\w. ]/gi, function(c){ return \u0026#39;\u0026amp;#\u0026#39;+c.charCodeAt(0)+\u0026#39;;\u0026#39;; }); }   1 2 3 4 5  function jsEscape(str){ return String(str).replace(/[^\\w. ]/gi, function(c){ return \u0026#39;\u0026amp;#x\u0026#39;+(\u0026#39;0000\u0026#39;+c.charCodeAt(0).toString(16)).slice(-4)+\u0026#39;;\u0026#39;; }); }   これらをブラウザで開いてからクリックすると、前者はアラートが実行され、後者は何も起こらない。\nこれはイベントハンドラでのみ起こるのか調べるために、unicodeエスケープのみを行った\u0026lt;img src=x onerror=alert(1)\u0026gt;をページに書き込んで開いてみる。\n1  \u0026amp;#x003c;img src\u0026amp;#x003d;x onerror\u0026amp;#x003d;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003e;   \u0026lt;img src=x onerror=alert(1)\u0026gt;と表示され、アラートは発火しない。\nイベントハンドラと同じJavaScriptコードがscriptタグに埋め込まれている場合を考える。\n以下のようなHTMLがサーバーによって生成される。\n1 2 3  \u0026lt;script\u0026gt; x=\u0026#39;\u0026amp;#x0027;\u0026amp;#x003b;alert\u0026amp;#x0028;1\u0026amp;#x0029;\u0026amp;#x003b;\u0026amp;#x0027;\u0026#39;; \u0026lt;/script\u0026gt;   これを開いてもアラートは実行されない。\nこれらからイベントハンドラでのみ実体参照が評価された状態でJavaScriptが実行されることがわかる。\n","date":"Nov 07","permalink":"https://mute1997.github.io/post/2020-11-07-entity-reference-in-event-handler/","tags":["security"],"title":"イベントハンドラでの実体参照の扱い"},{"categories":null,"contents":"以下の文書はx86についての説明です。\nメモリ配置 メモリ配置は以下の図のようになっています。\nテキストセグメントには実行されるコード、データセグメントは初期化済みのグローバル変数、bssセグメントには初期化されていないグローバル変数、ヒープセグメントは、mallocなどで動的に確保される変数が配置されます。\n今回はスタックに焦点をあてて説明していきます。\nスタック スタックとはメモリ上の領域の1つで、\n 引数の保存 ローカル変数の保存 関数呼び出し  に利用されます。\nスタックのアドレスは高値から低位に伸びていき、ebp, espレジスタにスタックのアドレスが保存されます。 以下の画像の様に、ebpは現在の関数のスタックの底を、espはスタックのトップを表しています。\nこれらのレジスタの値はpush, pop, call, retによって操作されます。\npushすると値がスタックに追加されたあとにespが4(x86_64の場合は8)だけデクリメントされ、popすると値がレジスタに読み込まれてespがインクリメントされます。\ncallの場合には、eipをリターンアドレスとしてpush, eipを呼び出し関数の先頭にセットします。 retすると、スタックからアドレスを取得してeipにセットします。\nスタックフレーム スタックフレームは以下の様になってます。\nリターンアドレスはcall命令によるもので、ebpのアドレスがあるのは、Function prologueによるものです。\nFunction prologue Function prologueは関数の先頭で行われる処理のことです。 実際には以下のような処理を行います。 push ebpでは、関数の終了時にebpを復元するために一旦スタックに退避しています。 mov ebp,espでは、現在のebpをespに代入することで、現在のスタックトップをベースにしています。\n1 2  push ebp mov ebp,esp   Function epilogue Function epilogueは関数の最後に行われる処理のことです。 実際には以下のような処理が行われています。\n1 2  leave ret   このleaveという命令は、\n1 2  mov esp ebp pop ebp   と同等の処理を行うものです。\nこれらは、espをebpに戻して、スタックからebpの値を復元します。 retでは、前のeipの値をスタックからポップして元のコードに戻ります。\ncalling convention スタックに引数を積む場合には、呼び出し規則(calling convention)と呼ばれる方法があります。 32bitバイナリでは、関数の引数は逆順にスタックに渡されます。 64bitバイナリでは、関数の引数を渡すのにスタックは使わず、レジスタを利用します。 渡される順番は以下の通りです。\n rdi rsi rdx r8 r9  5個を超えるような場合には32bitバイナリと同様にスタックにプッシュされます。\n","date":"Aug 22","permalink":"https://mute1997.github.io/post/2020-08-22-stack-and-calling-conventions/","tags":["linux"],"title":"スタックと呼び出し規約"},{"categories":null,"contents":"バイナリのFuzzingのようなものを、Webアプリにも適用できないだろうかと思って調べていた所見つけたのでちょっと読んでみようと思います。\n今回はアルゴリズム部分に注目して読んでみます。\nこの論文ではswaggerの静的分析を行いテストケースを生成しているらしい。\npythonっぽく書かれたアルゴリズムの疑似コードは以下の通り。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  Inputs: swaggerspec, maxLength # Swaggerから作成したリクエストの集合 reqSet = PROCESS(swaggerspec) # リクエストシーケンスの集合 (最初は空) seqSet = {} # メインループ n = 1 while (n \u0026lt;= maxLength): seqSet = EXTEND(seqSet, reqSet) seqSet = RENDER(seqSet) n = n + 1 # 依存関係が満たされている新しいリクエストを追加することで、 # seqSet内のすべてのシーケンスを拡張する def EXTEND(seqSet, reqSet): newSeqSet = {} for seq in seqSet: for req in reqSet: if DEPENDENCIES(seq, req): newSeqSet = newSeqSet + concat(seq, req) return newSeqSet # 辞書を利用して新たに追加されたすべてのリクエストを具体化し、 # それぞれの新しいリクエストシーケンスを実行し、有効なものを保持する def RENDER(seqSet): newSeqSet = {} for seq in seqSet: req = last_request_in(seq) ~V = tuple_of_fuzzable_types_in(req) for ~v in ~V: newReq = concretize(req,~v) newSeq = concat(seq, newReq) response = EXECUTE(newSeq) if response has a valid code: newSeqSet = newSeqSet + newSeq else: log error return newSeqSet # リクエストで参照されるすべてのオブジェクトが、 # 以前のリクエストシーケンスの何らかのレスポンスによって生成されたものであることをチェックします。 def DEPENDENCIES(seq, req): if CONSUMES(req)⊆PRODUCES(seq): return True else: return False # リクエストに必要なオブジェクト def CONSUMES(req): return object_types_required_in(req) # 一連のリクエストのレスポンスで生成されたオブジェクト def PRODUCES(seq): dynamicObjects ={} for req in seq: newObjs = objects_produced_in_response_of(req) dynamicObjects = dynamicObjects + newObjs return dynamicObjects   パパっと見てみると、\n 依存関係がある場合にはseqSetにreqを追加 seqSetの最後のAPIをfuzzing 200が帰ってきたものをseqSetに追加 を繰り返しているっぽい。  REST-lerを利用する場合には以下のコードを用いるっぽい。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  from restler import requests from restler import dependencies def parse_posts(data): post_id = data[\u0026#34;id\u0026#34;] dependencies.set_var(post_id) request = requests.Request( restler_static(\u0026#34;POST\u0026#34;), restler_static(\u0026#34;/api/blog/posts/\u0026#34;), restler_static(\u0026#34;HTTP/1.1\u0026#34;), restler_static(\u0026#34;{\u0026#34;), restler_static(\u0026#34;body\u0026#34;), restler_fuzzable(\u0026#34;string\u0026#34;), restler_static(\u0026#34;POST\u0026#34;), restler_static(\u0026#34;{\u0026#34;), \u0026#39;post_send\u0026#39;: { \u0026#39;parser\u0026#39;: parse_posts, \u0026#39;dependencies\u0026#39;: [ post_id.writer(), ], } )   依存関係があるっていうのはどうやって把握してるんだろうと思ってよく読んで見ると, シーケンスの最後に返されたレスポンスを含むリクエストは依存関係があると判断されるらしい。\n例えばシーケンスの最後がPOST /api/blog/postsとかだとレスポンスにはidが入っている、リクエストボディにidが入っているリクエストは依存関係があると判断されるのかな。\nこれは実際のコード読んでみないとよくわからないなぁと思って調べていたらソースコードの公開はないらしく、悲しい。\nhttps://twitter.com/vatlidak/status/1097099793514590208?s=21\n結果この手法でGitLabのバグを22個発見したということを言っている。\nクラッシュのグルーピングや探索方法についても記述があったがそのへんはちゃんと読んでないです。 気になる人は読んでみてください。\n","date":"Aug 13","permalink":"https://mute1997.github.io/post/2020-08-13-rest-ler/","tags":["security","paper"],"title":"論文紹介: REST-ler: Automatic Intelligent REST API Fuzzing"},{"categories":null,"contents":"DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。\nrootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC(https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c)についてまとめます。\nDirtyCowについて DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。 CVEではCVE-2016-5195として管理されています。\nhttps://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html\n前提知識など mmap mmapはファイルやデバイスをメモリにマッピングするためのものです。\nreadやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。\nそのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。\n\u0026ldquo;なるようです\u0026quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。\n日本語で詳しく解説されている記事があったのでどうぞ。\nman mmapしてでてくる情報を簡単にまとめます。 プロトタイプ宣言は次のようになっています。\n1  void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);   addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。\nlenにはマッピングするサイズを指定します。\nprotにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。\nflagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。\nfildesにはファイルディスクリプタを指定します。\noffにはファイルのオフセットを指定します。\nmmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/mman.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt; int main(int argc, char *argv[]){ if (argc \u0026lt;= 1) { printf(\u0026#34;please specify filename\\n\u0026#34;); return 1; } int fd = open(argv[1],O_RDONLY); if (fd \u0026lt; 0) { printf(\u0026#34;file not found\\n\u0026#34;); return 1; } printf(\u0026#34;file discriptor: %d\\n\u0026#34;, fd); struct stat st; fstat(fd, \u0026amp;st); printf(\u0026#34;file size: %ld\\n\u0026#34;, st.st_size); char* map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,fd,0); printf(\u0026#34;%s\\n\u0026#34;, map); return 0; }   更に詳しい情報はman mmapで得られます。\nCopy on Write Copy on Writeとは書き込みが行われるまでは元から存在するマッピングを利用し、書き込みが起こったと同時にメモリ上に新たに複製が作られるという動作のことをいいます。\nこれによってforkするたびに、メモリ上に複製を作るより効率よくメモリを利用することができます。\n書き込みによって作られた新たな複製は、他のプロセスからは見ることができません。\nここで実験のために少しコードを書いてみようと思います。\n先ほど説明したように、書き込みが行われるまでは同じマッピングを利用し、書き込みが行われるときに新たな領域が確保され、複製されます。\nプロセスのファイルマッピングは/proc/{pid}/smapsで確認することができます。\n出力はだいたいこんなのが得られます。\nSize: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 0 kB Pss: 0 kB Shared_Clean: 0 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 0 kB Referenced: 0 kB Anonymous: 0 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 0 kB VmFlags: rd mr mw me これを利用してみます。\n先程の説明通りなら、書き込みを行うまでは親プロセスと子プロセスのメモリマッピングは同じ、親プロセスか子プロセスどちらかで書き込むとメモリマッピングが変わるはずです。\n次のようなコード書いて実験してみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;sys/mman.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; #define IS_WRITE 1  int fd; struct stat st; void *map; int main(int argc, char *argv[]){ if (argc \u0026lt;= 1) { printf(\u0026#34;please specify filename\\n\u0026#34;); return 1; } fd = open(argv[1],O_RDWR); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return 1; } fstat(fd, \u0026amp;st); // MAP_PRIVATE(copy on write)でマッピング  map = (char *)mmap(NULL,st.st_size,PROT_WRITE,MAP_PRIVATE,fd,0); // 読み込み  FILE *f = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); fprintf(f, \u0026#34;%s\\n\u0026#34;, map); if (map == MAP_FAILED) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return -1; } int pid = getpid(); printf(\u0026#34;(main) pid: %d\\n\u0026#34;, pid); // -------------------  // fork  // -------------------  int status; pid = fork(); if (pid == 0) { pid = getpid(); printf(\u0026#34;(fork) pid: %d\\n\u0026#34;, pid); // 読み込み  FILE *f = fopen(\u0026#34;/dev/null\u0026#34;, \u0026#34;w\u0026#34;); fprintf(f, \u0026#34;%s\\n\u0026#34;, map); if (!IS_WRITE) sleep(100); // 書き込み  strcat(map, \u0026#34;A\u0026#34;); if (IS_WRITE) sleep(100); } wait(\u0026amp;status); // -------------------  if (munmap(map, st.st_size) == -1){ fprintf(stderr, \u0026#34;%s\\n\u0026#34;, strerror(errno)); return -1; } return 0; }   マッピングした領域に書き込む前にsleepを挟んでからコンパイルして実行します。\nsleepに入ったらcat /proc/{pid}/smaps | grep -A 20 filenameして子プロセスのマッピングをみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Size: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 4 kB Pss: 2 kB Shared_Clean: 4 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 0 kB Referenced: 4 kB Anonymous: 0 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 2 kB VmFlags: wr mr mw me ac   Shared_Cleanが4kBになってます。\n親プロセスと子プロセスで同じファイル触っているので共有されていますね。\n書き込みをしてから親プロセスのマッピングを見てみます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Size: 4 kB KernelPageSize: 4 kB MMUPageSize: 4 kB Rss: 4 kB Pss: 4 kB Shared_Clean: 0 kB Shared_Dirty: 0 kB Private_Clean: 0 kB Private_Dirty: 4 kB Referenced: 4 kB Anonymous: 4 kB LazyFree: 0 kB AnonHugePages: 0 kB ShmemPmdMapped: 0 kB Shared_Hugetlb: 0 kB Private_Hugetlb: 0 kB Swap: 0 kB SwapPss: 0 kB Locked: 4 kB VmFlags: wr mr mw me ac   Private_Dirtyが4kBになりましたね。\nマッピングしていたファイルが新しいプロセスのためにメモリ上に新たに複製されました。\nmadvise madviseはカーネルに、メモリのページング処理についてアドバイスを出すために使用します。\n1  int madvise(void *addr, size_t length, int advice);   addrにはアドレスを、lengthにはサイズ、adviceにはカーネルに対するアドバイスを渡します。詳細はman madviseで確認することが出来ます。\nDirtyCowではadviceにMADV_DONTNEEDが渡されています。\nこれは、しばらくは指定されたアドレスへのアクセスはなさそうなのでmmapしたメモリは一旦開放して良いということをカーネルに伝えるものです。\nこれによってmmapしたファイルは開放され、次に読み込むときは再びIOが発生し、メモリに読み込まれます。 元ファイルが削除されていた場合は0fillされます。\nPoCコードの解説 https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c\nPoCの大まかな動作としては、mainで読み込みたいファイルをmmap, それからmadviseThread, procselfmemThreadを各スレッドで動かしています。\nmadviseThreadではmadviseをループして何度も実行、procselfmemThreadでは自分のプロセスのメモリである/proc/self/memを開き、mmapされた場所に文字列を書き込み続けています。\nこの2つの動作が連続することにより競合状態が発生し、プライベートなメモリマップであるはずのものがディスクに書き込まれてしまいます。\nこれを理解する上で重要なのはページキャッシュの動作です。\nページキャッシュの動作として、読み込みが行われると、読み込んだものはキャッシュに置かれ、書き込みが行われると、即座に書き込みは行われず、キャッシュに書き込んだ上で適当なタイミングで書き込みが行われます。Linuxカーネルではキャッシュに書き込みを行うと書き込んだページにDirty bitが立てられます。\n先ほど説明したmadviseとwriteを繰り返すと、writeを行ってからDirty bitを立てる前にmadviseによってページがディスクに書き込まれることによって、権限の無いファイルに書き込みができてしまうというわけです。\ndraw.ioで2秒くらいで書いた図によるとこんな感じです。\n最後に 本当はパッチを読んだりしてたんですがこれ以上長くなるとしんどいのでやめました。\nDirtyCowのパッチには不十分で、THPを使用している場合にはCoWを用いることなくdirty bitを立てることができるらしいですね。\n気が向いたらパッチを読みつつ不十分だった部分など解説します。\n","date":"Aug 11","permalink":"https://mute1997.github.io/post/2018-08-11-how-dirtycow-work/","tags":["security"],"title":"DirtycowのPoCを読む"}]