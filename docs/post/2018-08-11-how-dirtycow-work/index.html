<!doctype html>
<html lang="en"><head>
    <title>Dirtycowはどのように動くか</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="../../css/theme.css"/>
    
</head>
<body>
        <div id="content" class="mx-auto"><header class="container mt-sm-5 mt-4 mb-4 mt-xs-1">
    <div class="row">
        <div class="col-sm-4 col-12 text-sm-right text-center pt-sm-4">
            <a href="../../" class="text-decoration-none">
                <img id="home-image" class="rounded-circle"
                    
                        src="../../images/avatar.png"
                    
                />
            </a>
        </div>
        <div class="col-sm-8 col-12 text-sm-left text-center">
            <h2 class="m-0 mb-2 mt-4">
                <a href="../../" class="text-decoration-none">
                    
                        Naoya Miyaguchi
                    
                </a>
            </h2>
            <p class="text-muted mb-1">
                
                    
                
            </p>
            <ul id="nav-links" class="list-inline mb-2">
                
                
                    <li class="list-inline-item">
                        <a class="badge badge-white " href="../../about/" title="About">About</a>
                    </li>
                
                    <li class="list-inline-item">
                        <a class="badge badge-white " href="../../post/" title="Posts">Posts</a>
                    </li>
                
                    <li class="list-inline-item">
                        <a class="badge badge-white " href="../../tags/" title="Tags">Tags</a>
                    </li>
                
            </ul>
            <ul id="nav-social" class="list-inline">
                
                    <li class="list-inline-item mr-3">
                        <a href="https://github.com/mute1997" target="_blank">
                            <i class="fab fa-github fa-1x text-muted"></i>
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
    <hr />
</header>
<div class="container">
    <div class="pl-sm-2">
        <div class="mb-3">
            <h3 class="mb-0">Dirtycowはどのように動くか</h3>
            
            <small class="text-muted">Published August 11, 2018</small>
        </div>

        <article>
            <p>DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。</p>
<p>rootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC([https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c:title])についてまとめます。</p>
<h4 id="dirtycowについて">DirtyCowについて</h4>
<p>DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。
CVEではCVE-2016-5195として管理されています。
[https://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html:title]</p>
<h4 id="前提知識など">前提知識など</h4>
<h5 id="mmap">mmap</h5>
<p>mmapはファイルやデバイスをメモリにマッピングするためのものです。</p>
<p>readやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。</p>
<p>そのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。</p>
<p>&ldquo;なるようです&quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。</p>
<p>日本語で詳しく解説されている<a href="https://www.allbsd.org/~hrs/blog/2017-01-02-read-mmap.html">記事</a>があったのでどうぞ。</p>
<p><code>man mmap</code>してでてくる情報を簡単にまとめます。
プロトタイプ宣言は次のようになっています。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t len, <span style="color:#66d9ef">int</span> prot, <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">int</span> fildes, off_t off);
</code></pre></div><p>addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。</p>
<p>lenにはマッピングするサイズを指定します。</p>
<p>protにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。</p>
<p>flagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。</p>
<p>fildesにはファイルディスクリプタを指定します。</p>
<p>offにはファイルのオフセットを指定します。</p>
<p>mmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
  <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) {
    printf(<span style="color:#e6db74">&#34;please specify filename</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  }

  <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(argv[<span style="color:#ae81ff">1</span>],O_RDONLY);
  <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
    printf(<span style="color:#e6db74">&#34;file not found</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  }
  printf(<span style="color:#e6db74">&#34;file discriptor: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, fd);

  <span style="color:#66d9ef">struct</span> stat st;
  fstat(fd, <span style="color:#f92672">&amp;</span>st);
  printf(<span style="color:#e6db74">&#34;file size: %ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, st.st_size);

  <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> map <span style="color:#f92672">=</span> mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,fd,<span style="color:#ae81ff">0</span>);
  printf(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, map);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>更に詳しい情報は<code>man mmap</code>で得られます。</p>
<h5 id="copy-on-write">Copy on Write</h5>
<p>Copy on Writeとは書き込みが行われるまでは元から存在するマッピングを利用し、書き込みが起こったと同時にメモリ上に新たに複製が作られるという動作のことをいいます。</p>
<p>これによってforkするたびに、メモリ上に複製を作るより効率よくメモリを利用することができます。</p>
<p>書き込みによって作られた新たな複製は、他のプロセスからは見ることができません。</p>
<p>ここで実験のために少しコードを書いてみようと思います。</p>
<p>先ほど説明したように、書き込みが行われるまでは同じマッピングを利用し、書き込みが行われるときに新たな領域が確保され、複製されます。</p>
<p>プロセスのファイルマッピングは<!-- raw HTML omitted -->/proc/{pid}/smaps<!-- raw HTML omitted -->で確認することができます。</p>
<p>出力はだいたいこんなのが得られます。</p>
<pre><code>Size:                  4 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                   0 kB
Pss:                   0 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            0 kB
Anonymous:             0 kB
LazyFree:              0 kB
AnonHugePages:         0 kB
ShmemPmdMapped:        0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
SwapPss:               0 kB
Locked:                0 kB
VmFlags: rd mr mw me
</code></pre><p>これを利用してみます。</p>
<p>先程の説明通りなら、書き込みを行うまでは親プロセスと子プロセスのメモリマッピングは同じ、親プロセスか子プロセスどちらかで書き込むとメモリマッピングが変わるはずです。</p>
<p>次のようなコード書いて実験してみます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;errno.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/wait.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define IS_WRITE 1
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> fd;
<span style="color:#66d9ef">struct</span> stat st;
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>map;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
  <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) {
    printf(<span style="color:#e6db74">&#34;please specify filename</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  }

  fd <span style="color:#f92672">=</span> open(argv[<span style="color:#ae81ff">1</span>],O_RDWR);

  <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
    fprintf(stderr, <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, strerror(errno));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  }

  fstat(fd, <span style="color:#f92672">&amp;</span>st);

  <span style="color:#75715e">// MAP_PRIVATE(copy on write)でマッピング
</span><span style="color:#75715e"></span>  map <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)mmap(NULL,st.st_size,PROT_WRITE,MAP_PRIVATE,fd,<span style="color:#ae81ff">0</span>);

  <span style="color:#75715e">// 読み込み
</span><span style="color:#75715e"></span>  FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;/dev/null&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>);
  fprintf(f, <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, map);

  <span style="color:#66d9ef">if</span> (map <span style="color:#f92672">==</span> MAP_FAILED) {
    fprintf(stderr, <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, strerror(errno));
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  <span style="color:#66d9ef">int</span> pid <span style="color:#f92672">=</span> getpid();
  printf(<span style="color:#e6db74">&#34;(main) pid: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);

  <span style="color:#75715e">// -------------------
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// fork
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// -------------------
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> status;
  pid <span style="color:#f92672">=</span> fork();

  <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
    pid <span style="color:#f92672">=</span> getpid();
    printf(<span style="color:#e6db74">&#34;(fork) pid: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);

    <span style="color:#75715e">// 読み込み
</span><span style="color:#75715e"></span>    FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;/dev/null&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>);
    fprintf(f, <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, map);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>IS_WRITE) sleep(<span style="color:#ae81ff">100</span>);

    <span style="color:#75715e">// 書き込み
</span><span style="color:#75715e"></span>    strcat(map, <span style="color:#e6db74">&#34;A&#34;</span>);
    <span style="color:#66d9ef">if</span> (IS_WRITE) sleep(<span style="color:#ae81ff">100</span>);
  }

  wait(<span style="color:#f92672">&amp;</span>status);
  <span style="color:#75715e">// -------------------
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">if</span> (munmap(map, st.st_size) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
    fprintf(stderr, <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, strerror(errno));
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>マッピングした領域に書き込む前にsleepを挟んでからコンパイルして実行します。</p>
<p>sleepに入ったらcat /proc/{pid}/smaps | grep -A 20 filenameして子プロセスのマッピングをみます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">Size:                  4 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                   4 kB
Pss:                   2 kB
Shared_Clean:          4 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            4 kB
Anonymous:             0 kB
LazyFree:              0 kB
AnonHugePages:         0 kB
ShmemPmdMapped:        0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
SwapPss:               0 kB
Locked:                2 kB
VmFlags: wr mr mw me ac
</code></pre></div><p>Shared_Cleanが4kBになってます。</p>
<p>親プロセスと子プロセスで同じファイル触っているので共有されていますね。</p>
<p>書き込みをしてから親プロセスのマッピングを見てみます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">Size:                  4 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                   4 kB
Pss:                   4 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         4 kB
Referenced:            4 kB
Anonymous:             4 kB
LazyFree:              0 kB
AnonHugePages:         0 kB
ShmemPmdMapped:        0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
SwapPss:               0 kB
Locked:                4 kB
VmFlags: wr mr mw me ac
</code></pre></div><p>Private_Dirtyが4kBになりましたね。</p>
<p>マッピングしていたファイルが新しいプロセスのためにメモリ上に新たに複製されました。</p>
<h5 id="madvise">madvise</h5>
<p>madviseはカーネルに、メモリのページング処理についてアドバイスを出すために使用します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">madvise</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t length, <span style="color:#66d9ef">int</span> advice);
</code></pre></div><p>addrにはアドレスを、lengthにはサイズ、adviceにはカーネルに対するアドバイスを渡します。詳細は<code>man madvise</code>で。</p>
<p>DirtyCowではadviceにMADV_DONTNEEDが渡されています。</p>
<p>これは、しばらくは指定されたアドレスへのアクセスはなさそうなのでmmapしたメモリは一旦開放して良いということをカーネルに伝えるものです。</p>
<p>これによってmmapしたファイルは開放され、次に読み込むときは再びIOが発生し、メモリに読み込まれます。
元ファイルが削除されていた場合は0fillされます。</p>
<h4 id="pocコードの解説">PoCコードの解説</h4>
<p><a href="https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c">https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c</a></p>
<p>PoCの大まかな動作としては、mainで読み込みたいファイルをmmap, それからmadviseThread, procselfmemThreadを各スレッドで動かしています。</p>
<p>madviseThreadではmadviseをループして何度も実行、procselfmemThreadでは自分のプロセスのメモリである<!-- raw HTML omitted -->/proc/self/mem<!-- raw HTML omitted -->を開き、mmapされた場所に文字列を書き込み続けています。</p>
<p>この2つの動作が連続することにより競合状態が発生し、プライベートなメモリマップであるはずのものがディスクに書き込まれてしまいます。</p>
<p>これを理解する上で重要なのはページキャッシュの動作です。</p>
<p>ページキャッシュの動作として、読み込みが行われると、読み込んだものはキャッシュに置かれ、書き込みが行われると、即座に書き込みは行われず、キャッシュに書き込んだ上で適当なタイミングで書き込みが行われます。Linuxカーネルではキャッシュに書き込みを行うと書き込んだページにDirty bitが立てられます。</p>
<p>先ほど説明したmadviseとwriteを繰り返すと、writeを行ってからDirty bitを立てる前にmadviseによってページがディスクに書き込まれることによって、権限の無いファイルに書き込みができてしまうというわけです。</p>
<p>draw.ioで2秒くらいで書いた図によるとこんな感じです。</p>





<img src="../../post/2018-08-11-how-dirtycow-work/describe-dirtycow_hubbf897366c95596523bba6ba4e6c4ca2_17309_600x600_fit_box_2.png" width="600" height="216" vspace="50" alt="describe-dirtycow">

<h4 id="最後に">最後に</h4>
<p>本当はパッチを読んだりしてたんですがこれ以上長くなるとしんどいのでやめました。</p>
<p>DirtyCowのパッチには不十分で、THPを使用している場合にはCoWを用いることなくdirty bitを立てることができるらしいですね。</p>
<p>気が向いたらパッチを読みつつ不十分だった部分など解説します。</p>

        </article>
    </div>

            </div>
        </div><footer class="text-center pb-1">
    <small class="text-muted">
        
            &copy; Copyright 2020, Naoya Miyaguchi
        
        <br>
        Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a>
        and <a href="https://github.com/austingebauer/devise" target="_blank">Devise</a>
    </small>
</footer>
</body>
</html>
