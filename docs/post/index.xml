<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>メモ帳</title>
    <link>https://mute1997.github.io/post/</link>
    <description>メモ帳</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 11 Aug 2018 00:00:00 +0000</lastBuildDate>
    
    <atom:link href="https://mute1997.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dirtycowはどのように動くか</title>
      <link>https://mute1997.github.io/post/how-dirtycow-work/</link>
      <pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/how-dirtycow-work/</guid>
      <description>&lt;p&gt;DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。&lt;/p&gt;
&lt;p&gt;rootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC([https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c:title])についてまとめます。&lt;/p&gt;
&lt;h1 id=&#34;dirtycowについて&#34;&gt;DirtyCowについて&lt;/h1&gt;
&lt;p&gt;DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。
CVEではCVE-2016-5195として管理されています。
[https://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html:title]&lt;/p&gt;
&lt;h1 id=&#34;前提知識など&#34;&gt;前提知識など&lt;/h1&gt;
&lt;h2 id=&#34;mmap&#34;&gt;mmap&lt;/h2&gt;
&lt;p&gt;mmapはファイルやデバイスをメモリにマッピングするためのものです。&lt;/p&gt;
&lt;p&gt;readやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。&lt;/p&gt;
&lt;p&gt;そのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;なるようです&amp;quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。&lt;/p&gt;
&lt;p&gt;日本語で詳しく解説されている&lt;a href=&#34;https://www.allbsd.org/~hrs/blog/2017-01-02-read-mmap.html&#34;&gt;記事&lt;/a&gt;があったのでどうぞ。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man mmap&lt;/code&gt;してでてくる情報を簡単にまとめます。
プロトタイプ宣言は次のようになっています。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mmap&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;addr, size_t len, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; prot, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; flags, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fildes, off_t off);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。&lt;/p&gt;
&lt;p&gt;lenにはマッピングするサイズを指定します。&lt;/p&gt;
&lt;p&gt;protにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。&lt;/p&gt;
&lt;p&gt;flagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。&lt;/p&gt;
&lt;p&gt;fildesにはファイルディスクリプタを指定します。&lt;/p&gt;
&lt;p&gt;offにはファイルのオフセットを指定します。&lt;/p&gt;
&lt;p&gt;mmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[]){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;please specify filename&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;],O_RDONLY);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fd &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;file not found&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
  }
  printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;file discriptor: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, fd);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; stat st;
  fstat(fd, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;st);
  printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;file size: %ld&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, st.st_size);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,fd,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
  printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, map);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更に詳しい情報は&lt;code&gt;man mmap&lt;/code&gt;で得られます。&lt;/p&gt;
&lt;h2 id=&#34;copy-on-write&#34;&gt;Copy on Write&lt;/h2&gt;
&lt;p&gt;Copy on Writeとは書き込みが行われるまでは元から存在するマッピングを利用し、書き込みが起こったと同時にメモリ上に新たに複製が作られるという動作のことをいいます。&lt;/p&gt;
&lt;p&gt;これによってforkするたびに、メモリ上に複製を作るより効率よくメモリを利用することができます。&lt;/p&gt;
&lt;p&gt;書き込みによって作られた新たな複製は、他のプロセスからは見ることができません。&lt;/p&gt;
&lt;p&gt;ここで実験のために少しコードを書いてみようと思います。&lt;/p&gt;
&lt;p&gt;先ほど説明したように、書き込みが行われるまでは同じマッピングを利用し、書き込みが行われるときに新たな領域が確保され、複製されます。&lt;/p&gt;
&lt;p&gt;プロセスのファイルマッピングは&lt;i&gt;/proc/{pid}/smaps&lt;/i&gt;で確認することができます。&lt;/p&gt;
&lt;p&gt;出力はだいたいこんなのが得られます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Size:                  4 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                   0 kB
Pss:                   0 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            0 kB
Anonymous:             0 kB
LazyFree:              0 kB
AnonHugePages:         0 kB
ShmemPmdMapped:        0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
SwapPss:               0 kB
Locked:                0 kB
VmFlags: rd mr mw me
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これを利用してみます。&lt;/p&gt;
&lt;p&gt;先程の説明通りなら、書き込みを行うまでは親プロセスと子プロセスのメモリマッピングは同じ、親プロセスか子プロセスどちらかで書き込むとメモリマッピングが変わるはずです。&lt;/p&gt;
&lt;p&gt;次のようなコード書いて実験してみます。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define IS_WRITE 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; stat st;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;map;

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[]){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;please specify filename&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
  }

  fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;],O_RDWR);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fd &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
    fprintf(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, strerror(errno));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
  }

  fstat(fd, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;st);

  &lt;span style=&#34;color:#75715e&#34;&gt;// MAP_PRIVATE(copy on write)でマッピング
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)mmap(NULL,st.st_size,PROT_WRITE,MAP_PRIVATE,fd,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);

  &lt;span style=&#34;color:#75715e&#34;&gt;// 読み込み
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  FILE &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fopen(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/dev/null&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);
  fprintf(f, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, map);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (map &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; MAP_FAILED) {
    fprintf(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, strerror(errno));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getpid();
  printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(main) pid: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, pid);

  &lt;span style=&#34;color:#75715e&#34;&gt;// -------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// fork
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// -------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; status;
  pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fork();

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
    pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getpid();
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(fork) pid: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, pid);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 読み込み
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    FILE &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fopen(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/dev/null&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);
    fprintf(f, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, map);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;IS_WRITE) sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 書き込み
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    strcat(map, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (IS_WRITE) sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);
  }

  wait(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;status);
  &lt;span style=&#34;color:#75715e&#34;&gt;// -------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (munmap(map, st.st_size) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
    fprintf(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, strerror(errno));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;マッピングした領域に書き込む前にsleepを挟んでからコンパイルして実行します。&lt;/p&gt;
&lt;p&gt;sleepに入ったらcat /proc/{pid}/smaps | grep -A 20 filenameして子プロセスのマッピングをみます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Size:                  4 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                   4 kB
Pss:                   2 kB
Shared_Clean:          4 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            4 kB
Anonymous:             0 kB
LazyFree:              0 kB
AnonHugePages:         0 kB
ShmemPmdMapped:        0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
SwapPss:               0 kB
Locked:                2 kB
VmFlags: wr mr mw me ac
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Shared_Cleanが4kBになってます。&lt;/p&gt;
&lt;p&gt;親プロセスと子プロセスで同じファイル触っているので共有されていますね。&lt;/p&gt;
&lt;p&gt;書き込みをしてから親プロセスのマッピングを見てみます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Size:                  4 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                   4 kB
Pss:                   4 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         4 kB
Referenced:            4 kB
Anonymous:             4 kB
LazyFree:              0 kB
AnonHugePages:         0 kB
ShmemPmdMapped:        0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
SwapPss:               0 kB
Locked:                4 kB
VmFlags: wr mr mw me ac
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Private_Dirtyが4kBになりましたね。&lt;/p&gt;
&lt;p&gt;マッピングしていたファイルが新しいプロセスのためにメモリ上に新たに複製されました。&lt;/p&gt;
&lt;h2 id=&#34;madvise&#34;&gt;madvise&lt;/h2&gt;
&lt;p&gt;madviseはカーネルに、メモリのページング処理についてアドバイスを出すために使用します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;madvise&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;addr, size_t length, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; advice);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;addrにはアドレスを、lengthにはサイズ、adviceにはカーネルに対するアドバイスを渡します。詳細は&lt;code&gt;man madvise&lt;/code&gt;で。&lt;/p&gt;
&lt;p&gt;DirtyCowではadviceにMADV_DONTNEEDが渡されています。&lt;/p&gt;
&lt;p&gt;これは、しばらくは指定されたアドレスへのアクセスはなさそうなのでmmapしたメモリは一旦開放して良いということをカーネルに伝えるものです。&lt;/p&gt;
&lt;p&gt;これによってmmapしたファイルは開放され、次に読み込むときは再びIOが発生し、メモリに読み込まれます。
元ファイルが削除されていた場合は0fillされます。&lt;/p&gt;
&lt;h1 id=&#34;pocコードの解説&#34;&gt;PoCコードの解説&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c&#34;&gt;https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PoCの大まかな動作としては、mainで読み込みたいファイルをmmap, それからmadviseThread, procselfmemThreadを各スレッドで動かしています。&lt;/p&gt;
&lt;p&gt;madviseThreadではmadviseをループして何度も実行、procselfmemThreadでは自分のプロセスのメモリである&lt;i&gt;/proc/self/mem&lt;/i&gt;を開き、mmapされた場所に文字列を書き込み続けています。&lt;/p&gt;
&lt;p&gt;この2つの動作が連続することにより競合状態が発生し、プライベートなメモリマップであるはずのものがディスクに書き込まれてしまいます。&lt;/p&gt;
&lt;p&gt;これを理解する上で重要なのはページキャッシュの動作です。&lt;/p&gt;
&lt;p&gt;ページキャッシュの動作として、読み込みが行われると、読み込んだものはキャッシュに置かれ、書き込みが行われると、即座に書き込みは行われず、キャッシュに書き込んだ上で適当なタイミングで書き込みが行われます。Linuxカーネルではキャッシュに書き込みを行うと書き込んだページにDirty bitが立てられます。&lt;/p&gt;
&lt;p&gt;先ほど説明したmadviseとwriteを繰り返すと、writeを行ってからDirty bitを立てる前にmadviseによってページがディスクに書き込まれることによって、権限の無いファイルに書き込みができてしまうというわけです。&lt;/p&gt;
&lt;p&gt;draw.ioで2秒くらいで書いた図によるとこんな感じです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./images/describe-dirtycow.png&#34; alt=&#34;describe-dirtycow&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;最後に&#34;&gt;最後に&lt;/h1&gt;
&lt;p&gt;本当はパッチを読んだりしてたんですがこれ以上長くなるとしんどいのでやめました。&lt;/p&gt;
&lt;p&gt;DirtyCowのパッチには不十分で、THPを使用している場合にはCoWを用いることなくdirty bitを立てることができるらしいですね。&lt;/p&gt;
&lt;p&gt;気が向いたらパッチを読みつつ不十分だった部分など解説します。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[rev 1.5] Nyquist keyboard build log</title>
      <link>https://mute1997.github.io/post/nyquist-keyboard-build-log-rev1.5/</link>
      <pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/nyquist-keyboard-build-log-rev1.5/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;./images/nyquist.jpg&#34; alt=&#34;nyquist&#34;&gt;&lt;/p&gt;
&lt;p&gt;Nyquistキーボードを作ったので僕の失敗談を交えつつBuild logを書いていこうと思います。&lt;/p&gt;
&lt;p&gt;これを読んだ皆さんはしょうもないことでミスって基板を書い直さなくて良いようにBuild logを穴が開くほど読んでください。&lt;/p&gt;
&lt;p&gt;それと僕は入ってないんですが自作キーボードDiscordなるものがあるらしいのでわからなくなったらそういうところで質問するのもいいと思います。&lt;/p&gt;
&lt;p&gt;それではどうぞ。&lt;/p&gt;
&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;
&lt;h3 id=&#34;必要な部品&#34;&gt;必要な部品&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;キートップ (aliexpress)&lt;/li&gt;
&lt;li&gt;キースイッチ(aliexpress)&lt;/li&gt;
&lt;li&gt;基板, ケース (keeb.io)&lt;/li&gt;
&lt;li&gt;ProMicro x 2 (keeb.io)&lt;/li&gt;
&lt;li&gt;TRRSケーブル x 1 (amazon)&lt;/li&gt;
&lt;li&gt;Micro USBケーブル x 1 (keeb.io)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;あったら良いものとか&#34;&gt;あったら良いものとか&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;クッションゴム&lt;/li&gt;
&lt;li&gt;セメダイン (ProMicroの端子固定用)&lt;/li&gt;
&lt;li&gt;4.7kΩの抵抗(I2C用)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;作るに当たって必要になる道具&#34;&gt;作るに当たって必要になる道具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;半田ごて一式&lt;/li&gt;
&lt;li&gt;ハンダ吸い取り線&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ハマりポイント&#34;&gt;ハマりポイント&lt;/h3&gt;
&lt;p&gt;ここからが重要なハマりポイントの説明になります。僕がハマったポイント、調べてるときによく見かけたハマりポイントを列挙して説明するので8億回くらい読んでください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ダイオードの向き&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;電気電子の人からしたら何言ってるんだという感じかもしれませんがダイオードは向きがあります。ダイオードのカソード（黒い帯がついてる方）はNyquistの基板のパターンが四角になってる方に実装しないといけないです。ダイオードを取り外すのはそこまで難しくないですが、なにぶん数が多いので間違って実装すると面倒です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ProMicroをつける順番&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは僕がハマったやつです。ちゃんとBuild Log読んでたら絶対起こり得ないことだとは思うんですが抵抗なくしてクソーっていいながら作業してたら間違えました。これはProMicroの方を先につけてしまうとキースイッチをつけられなくなってしまうという簡単なことです。ただこれを間違えるとProMicroの取り外しとかいう地獄みたいな作業が待ってるので絶対にミスしないことをおすすめします。ちなみに僕はProMicroのピンヘッダ取るの諦めて基板を書い直しました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./images/nyquist-with-keyswitch.jpg&#34; alt=&#34;nyquist-board-with-keyswitch&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ProMicroの端子&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;調べてるときに結構もげてる画像を見かけました。先ほど説明したようにProMicroのピンヘッダの取り外しは本当に地獄なので端子がとれてProMicroの交換をしなくていいように接着剤で固めるのをおすすめします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ProMicroのJ1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;僕のProMicroはそうではなかったのですがたまにProMicroのJ1がブリッジされててうまく動作しないことがあるようです。ブリッジされてるようならハンダ吸い取り線などで取ってください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ProMicroの裏表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;両方同じ向きで実装しちゃダメらしいです。(自分はミスしてないので両方同じ向きで実装するとどうなるのかわかってない)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ハンダの盛りすぎ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは他の人が書いているのは見たことはないけど自分が少し困ったこと。ハンダを盛りすぎていてキースイッチが奥まで押し込めなかった。（隙間からハンダ入れて少し吸った）キースイッチの実装をする前に基板全体のハンダ盛りすぎているところをチェックすると良いと思います。&lt;/p&gt;
&lt;h2 id=&#34;how-to-build&#34;&gt;How to build&lt;/h2&gt;
&lt;p&gt;簡単な作業ログです。
作ってる途中にあんまり写真取ってなくて画像が少ないのですがご了承ください。&lt;/p&gt;
&lt;h3 id=&#34;ダイオードの取り付け&#34;&gt;ダイオードの取り付け&lt;/h3&gt;
&lt;p&gt;まずはダイオードの取り付けです。ここで注意すべきは先ほど説明したダイオードの向きです。必ず黒い方をパターンが四角になっているところに実装しましょう。
&lt;img src=&#34;./images/nyquist-board.jpg&#34; alt=&#34;nyquist-board&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;trrs-ピンヘッダリセットスイッチの取り付け&#34;&gt;TRRS, ピンヘッダ、リセットスイッチの取り付け&lt;/h3&gt;
&lt;p&gt;画像がなくて申し訳ないんですがパパっと実装するだけという感じです。気をつける点としては同じ向きに実装してしまわないということくらいですかね。&lt;/p&gt;
&lt;h3 id=&#34;キースイッチの取り付け&#34;&gt;キースイッチの取り付け&lt;/h3&gt;
&lt;p&gt;!!! ProMicroの取り付け前に必ず行ってください。
この作業自体で特に注意することはないです。四隅から実装して浮かないように実装していくだけです。&lt;/p&gt;
&lt;h3 id=&#34;promicroの取り付け&#34;&gt;ProMicroの取り付け&lt;/h3&gt;
&lt;p&gt;ここまでくればもうほとんど終わったようなものです。ここで注意するのはProMicroの裏表です。同じ向きに実装してしまわないように気をつけて画像のように実装しましょう。
&lt;img src=&#34;./images/nyquist-with-micropro.jpg&#34; alt=&#34;nyquist-with-micropro&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;promicroにqmkを書き込む&#34;&gt;ProMicroにqmkを書き込む&lt;/h3&gt;
&lt;p&gt;今回はarchlinuxについてのみ説明します。Mac, Ubuntuとかは公式のドキュメントに従うだけなのでドキュメントよんでください。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ git clone &lt;a href=&#34;https://github.com/qmk/qmk_firmware.git&#34;&gt;https://github.com/qmk/qmk_firmware.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$ pacman -S &amp;ndash;noconfirm base-devel avr-gcc avr-binutils arv-libc dfu-util arm-none-eabi-gcc arm-none-eabi-binutils arm-none-eabi-newlib git diffutils avrdude&lt;/p&gt;
&lt;p&gt;$ cd qmk_firmware&lt;/p&gt;
&lt;p&gt;$ sudo make nyquist:default:avrdude&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;だいたいこんな感じです。最後のコマンドの実行時にリセットを求められるので取り付けたボタンを押してください。ここまでの作業で問題がなければ無事書き込まれるはずです。
あとはqmk_firmware/keyboards/nyquistにあるプロファイルをいじってお好きなキー配置を楽しんでください。&lt;/p&gt;
&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;
&lt;p&gt;初の自作キーボード、失敗したりもしましたが総じて楽しかったです。他にも色々種類があるようなので作ってみたさがある。&lt;/p&gt;
&lt;p&gt;そういえば調べているときにHoltite Socketなるものを見つけて気になっているので次回作る機会があればこういうのにも挑戦してみたい。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>