<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>メモ帳</title>
    <link>https://mute1997.github.io/post/</link>
    <description>Recent content on メモ帳</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Copyright 2020, Naoya Miyaguchi</copyright>
    <lastBuildDate>Sat, 22 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://mute1997.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>スタックと呼び出し規約</title>
      <link>https://mute1997.github.io/post/2020-08-22-stack-and-calling-conventions/</link>
      <pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2020-08-22-stack-and-calling-conventions/</guid>
      <description>以下の文書はx86についての説明です。
メモリ配置 メモリ配置は以下の図のようになっています。
テキストセグメントには実行されるコード、データセグメントは初期化済みのグローバル変数、bssセグメントには初期化されていないグローバル変数、ヒープセグメントは、mallocなどで動的に確保される変数が配置されます。
今回はスタックに焦点をあてて説明していきます。
スタック スタックとはメモリ上の領域の1つで、
 引数の保存 ローカル変数の保存 関数呼び出し  に利用されます。
スタックのアドレスは高値から低位に伸びていき、ebp, espレジスタにスタックのアドレスが保存されます。 以下の画像の様に、ebpは現在の関数のスタックの底を、espはスタックのトップを表しています。
これらのレジスタの値はpush, pop, call, retによって操作されます。
pushすると値がスタックに追加されたあとにespが4(x86_64の場合は8)だけデクリメントされ、popすると値がレジスタに読み込まれてespがインクリメントされます。
callの場合には、eipをリターンアドレスとしてpush, eipを呼び出し関数の先頭にセットします。 retすると、スタックからアドレスを取得してeipにセットします。
スタックフレーム スタックフレームは以下の様になってます。
リターンアドレスはcall命令によるもので、ebpのアドレスがあるのは、Function prologueによるものです。
Function prologue Function prologueは関数の先頭で行われる処理のことです。 実際には以下のような処理を行います。 push ebpでは、関数の終了時にebpを復元するために一旦スタックに退避しています。 mov ebp,espでは、現在のebpをespに代入することで、現在のスタックトップをベースにしています。
push ebp mov ebp,esp Function epilogue Function epilogueは関数の最後に行われる処理のことです。 実際には以下のような処理が行われています。
leave ret このleaveという命令は、
mov esp ebp pop ebp と同等の処理を行うものです。
これらは、espをebpに戻して、スタックからebpの値を復元します。 retでは、前のeipの値をスタックからポップして元のコードに戻ります。
calling convention スタックに引数を積む場合には、呼び出し規則(calling convention)と呼ばれる方法があります。 32bitバイナリでは、関数の引数は逆順に渡されます。 64bitバイナリでは、関数の引数を渡すのにスタックは使わず、レジスタを利用します。 渡される順番は以下の通りです。
 rdi rsi rdx r8 r9  5個を超えるような場合には32bitバイナリと同様にスタックにプッシュされます。</description>
    </item>
    
    <item>
      <title>論文紹介: fastboot oem vuln:Android Bootloader Vulnerabilities in Vendor Customizations</title>
      <link>https://mute1997.github.io/post/2020-08-14-fastboot-oem-vulm/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2020-08-14-fastboot-oem-vulm/</guid>
      <description>androidのブートローダ周りの脆弱性やファジングってどうやってるんだろうっての気になってたらこの論文を見つけました。
いつもどおり適当なのでちゃんと知りたかったら論文読んでください。
Introduction androidではchain-of-trustを通してセキュアブートを実装している。
PBLが次のブートローダの真正性を検証してSBLが起動、SBLがABOOTを検証するというのを続ける。 簡単にするとPBL -&amp;gt; SBL -&amp;gt; ABOOT -&amp;gt; boot.imgみたいな感じで起動していくっぽい。
ABOOTには通常モードとfastbootモードの2つのモードがある。 ABOOTはOSの実行前に実行されているため脆弱性も重要な深刻度を持っている。
この論文では例をいくつか紹介する。
fastbootの起動 fastbootは様々な方法で起動できると言ってる。
 キーの組み合わせ USBデバッグを有効にした状態でadb reboot  キーの組み合わせっていうのは何を指してるのかよくわからなかったので調べてみた所、以下のドキュメントを見つけた。
https://source.android.google.cn/setup/build/running?hl=ja#booting-into-fastboot-mode
キーの組み合わせって言うのは物理キーの組み合わせの話らしい。
自分が持ってるPixel 3a XLだと音量小を押したまま電源を長押しすると起動できるっぽい。
太古の昔にTWRPを入れるために似たような操作をやっていたけど完全に失念していた。
ABOOTTOOL OEMコマンドを発見するためにABOOTTOOLというファズツールを開発したらしい。 https://github.com/alephsecurity/abootool
これっぽい。
これによってメモリダンプ (ALEPH-2016000)などの脆弱性を発見できたと言ってる。
そして過去の脆弱性や今回見つかった脆弱性を4種類に分類して説明している。
 OSの完全性 データの流失 OSの隠れた機能 ICに対する攻撃  今回はOSの完全性の辺りに焦点を当てて見てみる。
OSの完全性 いくつかあるっぽいけど今回はCVE-2016-10277に注目してみる。
$ fastboot oem config console &amp;#34;a foo=A &amp;#34; $ fastboot oem config fsg-id &amp;#34;a bar=B&amp;#34; $ fastboot oem config carrier &amp;#34;a baz=C&amp;#34; [...] shamu:/ $ dmesg | grep command [ 0.</description>
    </item>
    
    <item>
      <title>論文紹介: REST-ler: Automatic Intelligent REST API Fuzzing</title>
      <link>https://mute1997.github.io/post/2020-08-13-rest-ler/</link>
      <pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2020-08-13-rest-ler/</guid>
      <description>fuzzingみたいな感じで脆弱性発見の自動化をWebアプリとかにはうまく適用できないんだろうかと思って調べていた所見つけたのでちょっと読んでみようと思います。
今回はアルゴリズム部分に注目して読んでみます。
この論文ではswaggerの静的分析を行いテストケースを生成しているらしい。
pythonっぽく書かれたアルゴリズムの疑似コードは以下の通り。
Inputs: swaggerspec, maxLength # Swaggerから作成したリクエストの集合 reqSet = PROCESS(swaggerspec) # リクエストシーケンスの集合 (最初は空) seqSet = {} # メインループ n = 1 while (n &amp;lt;= maxLength): seqSet = EXTEND(seqSet, reqSet) seqSet = RENDER(seqSet) n = n + 1 # 依存関係が満たされている新しいリクエストを追加することで、 # seqSet内のすべてのシーケンスを拡張する def EXTEND(seqSet, reqSet): newSeqSet = {} for seq in seqSet: for req in reqSet: if DEPENDENCIES(seq, req): newSeqSet = newSeqSet + concat(seq, req) return newSeqSet # 辞書を利用して新たに追加されたすべてのリクエストを具体化し、 # それぞれの新しいリクエストシーケンスを実行し、有効なものを保持する def RENDER(seqSet): newSeqSet = {} for seq in seqSet: req = last_request_in(seq) ~V = tuple_of_fuzzable_types_in(req) for ~v in ~V: newReq = concretize(req,~v) newSeq = concat(seq, newReq) response = EXECUTE(newSeq) if response has a valid code: newSeqSet = newSeqSet + newSeq else: log error return newSeqSet # リクエストで参照されるすべてのオブジェクトが、 # 以前のリクエストシーケンスの何らかのレスポンスによって生成されたものであることをチェックします。 def DEPENDENCIES(seq, req): if CONSUMES(req)⊆PRODUCES(seq): return True else: return False # リクエストに必要なオブジェクト def CONSUMES(req): return object_types_required_in(req) # 一連のリクエストのレスポンスで生成されたオブジェクト def PRODUCES(seq): dynamicObjects ={} for req in seq: newObjs = objects_produced_in_response_of(req) dynamicObjects = dynamicObjects + newObjs return dynamicObjects パパっと見てみると、</description>
    </item>
    
    <item>
      <title>論文紹介: Memory-Safety Challenge Considered Solved? An In-DepthExperience Report with All Rust CVEs</title>
      <link>https://mute1997.github.io/post/2020-08-08-memory-safety-challenge-considered-solved/</link>
      <pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2020-08-08-memory-safety-challenge-considered-solved/</guid>
      <description>ふとRustで書かれたソフトウェアでは絶対にメモリ系のバグが起こらないのか気になりました。 メモリ系のバグが起こらないとしたらファジングで脆弱性を見つけることは出来ないがパニックするパターンは発見できる？ その辺りがちょっと気になっていた所、この論文[1]を見つけたので読みました。 正確な翻訳ではなく、ちょっとしたまとめとただの感想です。
この論文ではRustに存在する脆弱性のリストを調査して, メモリ安全性を達成出来るのかどうかを調査している。 リストは以下の２つ。
Advisory-db
Trophy-cases
このリストを調査したところ、Rustによってuse-after-free, double-freeの問題を新たに引き起こしてしまう場合があるということを言っている。
今回はUse-After-Free, Double-Free辺りの問題を見てみる。
Use-After-Free コンストラクタにunsafeを使った場合にUse-After-Freeが発生するということを言ってる。
例として以下のコードを考える。
このコードでは、コンストラクタではポインタの引数をdereferenceして参照を返す。 しかし、関数の終了時にこの参照が開放されてしまうので、mainで参照するとUse-After-Freeが発生する。
fn test() -&amp;gt; Vec&amp;lt;u8&amp;gt; { let mut s = String::from(&amp;#34;lifetime_test&amp;#34;); let ptr = s.as_mut_ptr(); unsafe { let v = Vec::from_raw_parts(ptr, s.len(), s.len()); v } } fn main() { let v = test(); assert_eq!(&amp;#39;l&amp;#39; as u8, v[0]); /*fail*/ } Double-Free Double-Freeはいろいろ起こりうるシチュエーションはあるみたいだけど、とりあえず以下のコードを考える。 srcがfun1のスコープを抜けるときに開放され、mainのスコープを抜けるときにfooの開放をしようとしてdouble-freeが発生する。
impl Drop for Foo { fn drop(&amp;amp;mut self) { println!(&amp;#34;Dropping: {}&amp;#34;,self.s); } } struct Foo {s: String} /*fix2:struct Foo {s: mem::ManuallyDrop&amp;lt;String&amp;gt;}*/ fn fun2(mut src: &amp;amp;mut String) -&amp;gt; Foo { let s = unsafe{ String::from_raw_parts(src.</description>
    </item>
    
    <item>
      <title>preenyを利用したサーバーのファジング</title>
      <link>https://mute1997.github.io/post/2020-08-08-fuzz-app-that-use-sockets/</link>
      <pubDate>Sat, 08 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2020-08-08-fuzz-app-that-use-sockets/</guid>
      <description>最近AFLを利用していろんなソフトウェアのファジングをしています。 AFLとは、テスト手法であるファジングの一種でgreybox-fuzzingに分類されるものです。 詳しい使い方や詳細は以下を参照してください。
https://github.com/google/AFL
このAFLでは標準入力、もしくは引数からファイルとして受け取り、処理をした後に即座に終了するというアプリケーションが期待されます。 nginxなどのWebサーバーはイベントループがあり、ソケットを利用するためにAFLをそのまま利用することが出来ません。
イベントループは自分で即座にbreakすることですぐに終了することが出来ますが、ソケットの問題はpreenyで解決出来ます。
preenyとは https://github.com/zardus/preeny
preenyとは、LD_PRELOADでライブラリ関数を上書きするものです。 いくつかモジュールがありますが、desockというものを利用することでsocket()、bind()、listen()、accept()あたりが上書きされるようです。 これを利用することで、ソケット操作はstdin、stdoutを読み書きするようになるので、AFLで利用することができます。
shadowsocksで試してみる nginxとかでやろうと思ったんですが同じことをやっている英語記事を書いている途中に見つけてしまったのでshadowsocksでやります。
shadowsocksは中国で開発されたプロキシツールです。 オリジナルは中国政府から削除を要請されたようで、今は以下のレポジトリで開発が進んでいます。
https://github.com/shadowsocks/shadowsocks-libev
イベントループを止める shadowsocksはlibevを使ってイベントループを処理しています。
server.cにエントリーポイントがあるのでここから読み進めていきます。 読み進めていくと, server_recv_cb()という関数で受信処理をしているようです。 この関数をラップして, この関数の終了時にイベントループを終わらせるようにします。
static void server_recv_once_cb(EV_P_ ev_io *w, int revents) { server_recv_cb(loop, w, revents); ev_break(EV_A_ EVBREAK_ONE); } static server_t * new_server(int fd, listen_ctx_t *listener) { ... ev_io_init(&amp;amp;server-&amp;gt;recv_ctx-&amp;gt;io, server_recv_once_cb, fd, EV_READ); ... } こうすることで, リクエストを１つ受け取ったら終了するようになりました。
afl-gccでコンパイルするように変更 src/Makefileを編集してgccと書いてあるところをafl-gccにしていきます。
... CC = afl-gcc ... コンパイルします。 コンパイル途中にInstrumented n locationsみたいな表示が出てきたらAFLを利用して, コンパイル出来ています。
$ make afl-cc 2.</description>
    </item>
    
    <item>
      <title>Dirtycowはどのように動くか</title>
      <link>https://mute1997.github.io/post/2018-08-11-how-dirtycow-work/</link>
      <pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2018-08-11-how-dirtycow-work/</guid>
      <description>DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。
rootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC([https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c:title])についてまとめます。
DirtyCowについて DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。 CVEではCVE-2016-5195として管理されています。 [https://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html:title]
前提知識など mmap mmapはファイルやデバイスをメモリにマッピングするためのものです。
readやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。
そのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。
&amp;ldquo;なるようです&amp;quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。
日本語で詳しく解説されている記事があったのでどうぞ。
man mmapしてでてくる情報を簡単にまとめます。 プロトタイプ宣言は次のようになっています。
void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off); addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。
lenにはマッピングするサイズを指定します。
protにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。
flagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。
fildesにはファイルディスクリプタを指定します。
offにはファイルのオフセットを指定します。
mmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt; int main(int argc, char *argv[]){ if (argc &amp;lt;= 1) { printf(&amp;#34;please specify filename\n&amp;#34;); return 1; } int fd = open(argv[1],O_RDONLY); if (fd &amp;lt; 0) { printf(&amp;#34;file not found\n&amp;#34;); return 1; } printf(&amp;#34;file discriptor: %d\n&amp;#34;, fd); struct stat st; fstat(fd, &amp;amp;st); printf(&amp;#34;file size: %ld\n&amp;#34;, st.</description>
    </item>
    
    <item>
      <title>[rev 1.5] Nyquist keyboard build log</title>
      <link>https://mute1997.github.io/post/2018-03-04-nyquist-keyboard-build-log-rev1.5/</link>
      <pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2018-03-04-nyquist-keyboard-build-log-rev1.5/</guid>
      <description>Nyquistキーボードを作ったので僕の失敗談を交えつつBuild logを書いていこうと思います。
これを読んだ皆さんはしょうもないことでミスって基板を書い直さなくて良いようにBuild logを穴が開くほど読んでください。
それと僕は入ってないんですが自作キーボードDiscordなるものがあるらしいのでわからなくなったらそういうところで質問するのもいいと思います。
それではどうぞ。
準備 必要な部品  キートップ (aliexpress) キースイッチ(aliexpress) 基板, ケース (keeb.io) ProMicro x 2 (keeb.io) TRRSケーブル x 1 (amazon) Micro USBケーブル x 1 (keeb.io)  あったら良いものとか  クッションゴム セメダイン (ProMicroの端子固定用) 4.7kΩの抵抗(I2C用)  作るに当たって必要になる道具  半田ごて一式 ハンダ吸い取り線  ハマりポイント ここからが重要なハマりポイントの説明になります。僕がハマったポイント、調べてるときによく見かけたハマりポイントを列挙して説明するので8億回くらい読んでください。
 ダイオードの向き  電気電子の人からしたら何言ってるんだという感じかもしれませんがダイオードは向きがあります。ダイオードのカソード（黒い帯がついてる方）はNyquistの基板のパターンが四角になってる方に実装しないといけないです。ダイオードを取り外すのはそこまで難しくないですが、なにぶん数が多いので間違って実装すると面倒です。
 ProMicroをつける順番  これは僕がハマったやつです。ちゃんとBuild Log読んでたら絶対起こり得ないことだとは思うんですが抵抗なくしてクソーっていいながら作業してたら間違えました。これはProMicroの方を先につけてしまうとキースイッチをつけられなくなってしまうという簡単なことです。ただこれを間違えるとProMicroの取り外しとかいう地獄みたいな作業が待ってるので絶対にミスしないことをおすすめします。ちなみに僕はProMicroのピンヘッダ取るの諦めて基板を書い直しました。
 ProMicroの端子  調べてるときに結構もげてる画像を見かけました。先ほど説明したようにProMicroのピンヘッダの取り外しは本当に地獄なので端子がとれてProMicroの交換をしなくていいように接着剤で固めるのをおすすめします。
 ProMicroのJ1  僕のProMicroはそうではなかったのですがたまにProMicroのJ1がブリッジされててうまく動作しないことがあるようです。ブリッジされてるようならハンダ吸い取り線などで取ってください。
 ProMicroの裏表  両方同じ向きで実装しちゃダメらしいです。(自分はミスしてないので両方同じ向きで実装するとどうなるのかわかってない)
 ハンダの盛りすぎ  これは他の人が書いているのは見たことはないけど自分が少し困ったこと。ハンダを盛りすぎていてキースイッチが奥まで押し込めなかった。（隙間からハンダ入れて少し吸った）キースイッチの実装をする前に基板全体のハンダ盛りすぎているところをチェックすると良いと思います。
How to build 簡単な作業ログです。 作ってる途中にあんまり写真取ってなくて画像が少ないのですがご了承ください。</description>
    </item>
    
  </channel>
</rss>