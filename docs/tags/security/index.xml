<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>security on mute1997.github.io</title>
    <link>https://mute1997.github.io/tags/security/</link>
    <description>Recent content in security on mute1997.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://mute1997.github.io/tags/security/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>セキュアなソフトウェア開発とは何かをNIST SSDF v1.1から読み解く</title>
      <link>https://mute1997.github.io/post/2022-10-15-nist-ssdf-v1.1/</link>
      <pubDate>Fri, 14 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-10-15-nist-ssdf-v1.1/</guid>
      <description>NIST SSDF v1.1の概要  この文書は、以下の4つのグループから構成されています。
 Prepare the Organization (組織を準備する) Protect the Software (ソフトウェアを守る) Produce Well-Secured Software (セキュアなソフトウェアを作る) Respond to Vulnerabilities (脆弱性に対処する)  これらのグループには、いくつかのプラクティスが含まれます。 プラクティスには、タスク、想定される実施例、参考文献が含まれます。
この記事では、プラクティスに焦点を当て、プラクティスを実践するためのツールやフレームワークについて記述します。 プラクティスの翻訳や解釈には独自の考えを含むので、組織や状況によって上手く変更して適用してください。 断りがない場合、基本的にはWebアプリケーション開発を想定して記述します。
   Prepare the Organization (PO)  PO.1: ソフトウェア開発のためのセキュリティ要件を定義する PO.2: 役割と責任を導入する PO.3: サポートツールチェーンを導入する PO.4: ソフトウェアのセキュリティチェックのための基準を定義し使用する PO.5: ソフトウェア開発のための安全な環境を実装し維持する この章では、セキュアな開発に取り組む上で必要となる事柄について記述されています。
PO.1でセキュリティ要件を定義すると記述されていますが、一から要件を作って行くのは大変です。 組織で作っているものがWebアプリケーションである場合は、OWASP ASVSなどが使えそうです。 OWASP ASVSは一般的なWebアプリケーションに利用する想定なので、組織固有の要件を洗い出すには脅威モデリングなどが活用できそうです。
PO.2は、セキュリティチャンピオンの指名や教育というアクションが適当そうです。 セキュリティチャンピオンについては、以下のような資料が参考になります。
 OWASP Security Culture メルカリで「セキュリティチャンピオン」育成プログラムが開始！その内容と“発足した理由”を紹介  PO.3は、DAST / SAST / SCAや、その他ツール類の導入が適当そうです。 このあたりのツールは無数にあるので、開発の邪魔にならない範囲で順番に対処していくのが良さそうです。
PO.4、PO.5は組織やアプリケーションによって異なります。</description>
    </item>
    
    <item>
      <title>semgrep-smart-contractsをすべて読む #04 (basic-arithmetic-underflow)</title>
      <link>https://mute1997.github.io/post/2022-06-07-semgrep-smart-contracts-4/</link>
      <pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-06-07-semgrep-smart-contracts-4/</guid>
      <description>semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。
今回は、basic-arithmetic-underflowというルールを読んでみます。
 basic-arithmetic-underflow.yaml basic-arithmetic-underflow.sol     検出ルール  検出ルールは、以下の通りです。
このルールはまだBETAであり、まだsemgrepでは検出できません。
1 2 3 4 5 6 7 8  pattern-sinks:- pattern:$Y - $Xpattern-sources:- pattern-either:- pattern-inside:|function $F(..., $X, ...) external { ... }- pattern-inside:|function $F(..., $X, ...) public { ... }     underflowとは  solidityの特定のバージョンでは、型の下限値を超えてデクリメントをしてしまった場合、意図しない動作を誘発する恐れがあります。
例として、solidityでuint8の変数を使うことを考えます。
このuint8の変数が0のとき、デクリメントすると255になってしまいます。
1 2  uint8 balance = 0; balance--; // balance == 255   この挙動は、solidity &amp;gt;= 0.</description>
    </item>
    
    <item>
      <title>Security Innovation Blockchain CTF - Piggy Bank</title>
      <link>https://mute1997.github.io/post/2022-06-04-piggybank-writeup/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-06-04-piggybank-writeup/</guid>
      <description>概要  Security Innovation Blockchain CTF
Security Innovationという企業が開催している、常設のCTFがあります。 今回は、Piggy Bankという問題を解きました。
   問題  貯金箱のようなアプリで、ownerのみが資金を出し入れできる実装になっています。
   ソースコードを読む  PiggyBankというコントラクトが本体の実装になっており、CharliesPiggyBankはそれを継承したアプリです。
CharliesPiggyBankは、collectFundsという資金引き出し用の関数のみをoverrideしています。
PiggyBankにはonlyOwnerというmodifierが付いているものの、CharliesPiggyBankでoverrideされた関数では、modifierが付与されていません。
そのため、継承先のアプリではcollectFundsが誰でも呼び出し可能になっているようです。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  pragma solidity 0.</description>
    </item>
    
    <item>
      <title>Security Innovation Blockchain CTF - Lock Box</title>
      <link>https://mute1997.github.io/post/2022-06-01-lockbox-writeup/</link>
      <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-06-01-lockbox-writeup/</guid>
      <description>概要  Security Innovation Blockchain CTF
Security Innovationという企業が開催している、常設のCTFがあります。 今回は、Lock Boxという問題を解きました。
   問題  問題を開くと、以下のような画面が出てきます。
ピンを入力してUnlockボタンを押すと、スマートコントラクトが保有している資産を取得できるというアプリのようです。
   ソースコードを読む  constructorではアンロックするためのpinが生成されており、unlock関数で資金を送金するというコードのようです。
unlock関数はpinを受け取り、constructorで生成したpinと同一であれば、資金が送金されるようです。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  pragma solidity 0.4.24; import &amp;#34;../CtfFramework.sol&amp;#34;; contract Lockbox1 is CtfFramework{ uint256 private pin; constructor(address _ctfLauncher, address _player) public payable CtfFramework(_ctfLauncher, _player) { pin = now%10000; } function unlock(uint256 _pin) external ctf{ require(pin == _pin, &amp;#34;Incorrect PIN&amp;#34;); msg.</description>
    </item>
    
    <item>
      <title>スマートコントラクトの検査ツール調査</title>
      <link>https://mute1997.github.io/post/2022-05-18-solidity-tools/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-05-18-solidity-tools/</guid>
      <description>スマートコントラクトに対する検査ツールについて調査しました。
   Mythril  MythrilはEVMバイトコードに対する検査ツールです。 Symbolic execution / SMT resolver / taint analysisを使用して、問題の検出を行います。
検出可能なモジュールは以下のページで確認できます。
Analysis Modules
   MythX  複数の静的解析ツールを組み合わせたSaaSサービスです。
詳細は以下のブログで確認できます。
MythX Tech: Behind the Scenes of Smart Contract Security Analysis
このブログによると、内部的には以下のツールが用いられているようです。
 Maru (Static code analysis) Harvey (Greybox Fuzzing) Mythril (Symbolic Execution and SMT Solving)  Maruについては情報が見つかりませんでしたが、Harveyというツールは、論文として発表されているツールのようです。
Harvey: A Greybox Fuzzer for Smart Contracts
   slither  SlithIRという中間表現を利用し、テイント解析を行うツールです。
2022年5月現在、76のDetectorに対応しているようです。
以下のページで、今まで検出した脆弱性の一覧がリストされています。
https://github.com/crytic/slither/blob/master/trophies.md
   Echidna  スマートコントラクトのファジングツールです。古典的なファザーのようにクラッシュを探すのではなく、不変状態を破ろうとするプロパティベースのファジングツールです。</description>
    </item>
    
    <item>
      <title>semgrep-smart-contractsをすべて読む #03 (basic-reentrancy)</title>
      <link>https://mute1997.github.io/post/2022-05-12-semgrep-smart-contracts-3/</link>
      <pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-05-12-semgrep-smart-contracts-3/</guid>
      <description>semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。
今回は、basic-reentrancyというルールを読んでみます。
 basic-reentrancy.yaml basic-reentrancy.sol     検出ルール  検出ルールは、以下の通りです。
このルールはまだBETAであり、まだsemgrepでは検出できません。
1 2 3 4 5 6 7 8 9  patterns:- pattern-either:- pattern-inside:|function $F(..., $X, ...) external { ... }- pattern-inside:|function $F(..., $X, ...) public { ... }- pattern-not-inside:|function $F(..., $X, ...) onlyOwner { ... }- pattern:$X.$M(...)     Reentrancy attackとは  reentrant (再入可能性) とは、ある関数の実行中に、同じ関数を実行しても安全であるという性質のことを指します。
スマートコントラクトにおいては、攻撃対象から、任意のコントラクトを呼び出し可能な場合にReentrancy attackが発生する恐れがあります。
この攻撃は、以下の論文で詳細に解説されています。
Reentrancy Vulnerability Identification in Ethereum Smart Contracts</description>
    </item>
    
    <item>
      <title>Security Innovation Blockchain CTF - Donation</title>
      <link>https://mute1997.github.io/post/2022-05-12-donation-writeup/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-05-12-donation-writeup/</guid>
      <description>概要  Security Innovation Blockchain CTF
Security Innovationという企業が開催している、常設のCTFがあります。 今回は、Donationという問題を解きました。
   問題  問題を開くと、寄付をするためのアプリケーションであることが分かります。
Donate 0.1 Ether!をクリックするとMetaMaskが起動し、0.1 Etherが寄付されます。
このアプリケーションのソースコードとして、以下のSolidityファイルが渡されます。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  pragma solidity 0.4.24; import &amp;#34;../CtfFramework.sol&amp;#34;; import &amp;#34;../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol&amp;#34;; contract Donation is CtfFramework{ using SafeMath for uint256; uint256 public funds; constructor(address _ctfLauncher, address _player) public payable CtfFramework(_ctfLauncher, _player) { funds = funds.</description>
    </item>
    
    <item>
      <title>semgrep-smart-contractsをすべて読む #02 (arbitrary-low-level-call)</title>
      <link>https://mute1997.github.io/post/2022-05-04-semgrep-smart-contracts-2/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-05-04-semgrep-smart-contracts-2/</guid>
      <description>semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。
今回は、arbitrary-low-level-callというルールを読んでみます。
 arbitrary-low-level-call.yaml arbitrary-low-level-call.sol     検出ルール  検出ルールは、以下の通りです。
このルールは、betaであり、semgrepではまだ検出は出来ないようです。
1 2 3 4 5 6 7  patterns:- pattern-either:- pattern-inside:|function $F(..., $ADDR, ...) external { ... }- pattern-inside:|function $F(..., $ADDR, ...) public { ... }- pattern:$ADDR.call($DATA);  この脆弱性は、引数で渡されたアドレスに対し、call関数が呼ばれた場合に検知するものです。
call関数は、アドレス型の関数で、別スマートコントラクトの関数を呼び出すためのものです。 詳細は以下のドキュメントを参照してください。 https://docs.soliditylang.org/en/develop/types.html#members-of-addresses
この脆弱性は、特定のスマートコントラクトやユーザーに対してのみ許可している操作を、攻撃者が任意で呼び出せてしまうことに問題があります。
攻撃者は、transferFromなどの送金用関数を自分のアドレスに対して利用することで、資金を盗むことが可能になります。
   Li Financeでの事例  この脆弱性を悪用した攻撃が、Li Financeで発生しました。 攻撃トランザクションとエクスプロイトコードは以下の通りです。
 Transaction Exploit  問題が起こったのは、swapAndStartBridgeTokensViaCBridge関数です。
この関数は、_swapDataという関数を受け取り、callDataを引数としてcallToに対して関数が呼び出されています。
1 2 3 4 5 6 7 8 9 10 11  function swapAndStartBridgeTokensViaCBridge( LiFiData memory _lifiData, LibSwap.</description>
    </item>
    
    <item>
      <title>semgrep-smart-contractsをすべて読む #01 (basic-oracle-manipulation)</title>
      <link>https://mute1997.github.io/post/2022-04-20-semgrep-smart-contracts-1/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2022-04-20-semgrep-smart-contracts-1/</guid>
      <description>semgrep-smart-contracts というリポジトリがあります。 これは、スマートコントラクトの脆弱性を発見するためのsemgrepルールをまとめたものです。
このリポジトリの、検出ルールと脆弱なコードを読んでいくことで、スマートコントラクトの脆弱性を学びます。今回は、以下のルールを読んでいきます。
 basic-oracle-manipulation.yaml basic-oracle-manipulation.sol     検出ルール  まず、semgrepのルールを理解するために、ルールを日本語として表現します。
 関数内の処理であること 関数の名称が (?i)get([a-z0-9_])*price にマッチすること $X.div($Y)、もしくは$X / $Yであること $Xは以下の文字列のどれかを含むこと  underlying underlyingUnit pair reserve reserve0 reserve1   $Yは.*totalSupply.*にマッチすること  このルールを実行すると、以下の2つがsemgrepによって検出されます。
1 2 3  101┆ _sharePrice = totalSupply() == 0 102┆ ? underlyingUnit 103┆ : underlyingUnit.mul(balanceWithInvested()).div(totalSupply());   1 2  355┆ ((dei.balanceOf(address(pair)) + (usdc.balanceOf(address(pair)) * 1e12)) * 356┆ 1e18) / pair.totalSupply();   ルールと、何が検出されるのかは分かったものの、これだけでは何が脆弱なのか分からないので、エクスプロイトを調べてみます。</description>
    </item>
    
    <item>
      <title>RPOとOpenRedirectを用いたXSS</title>
      <link>https://mute1997.github.io/post/2021-07-21-rpo/</link>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2021-07-21-rpo/</guid>
      <description>RPOとは、Gareth Heyesが提唱した脆弱性です。(http://www.thespanner.co.uk/2014/03/21/rpo/)
この脆弱性の理解のため、今回はintigritiのXSS Challengeで出題された問題の再現を行います。 この問題の詳細は以下の動画で確認できます。
 上記の動画では、http://vulnerable-server//example.com/..にアクセスを行い、相対パスで読み込んでいるリソースの起点をhttp://vulnerable-server//example.comとすることで、任意のスクリプトの実行を行なっています。
http://vulnerable-server//example.com/..へのアクセスは、サーバーの仕様によりhttp://vulnerable-server/にアクセスした時と同じコンテンツが返却されます。
http://vulnerable-server/では、以下の様に相対パスでのスクリプトの読み込みを行なっているため、http://vulnerable-server//example.com/script.jsからスクリプトが読み込まれます。
1  &amp;lt;script src=script.js&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;!-- http://vulnerable-server//example.com/script.js--&amp;gt;   http://vulnerable-server//example.com/script.jsへのアクセスは、リダイレクトの機能が動作するため、実際にはhttp://example.com/script.jsから読み込まれます。
攻撃者はexample.comの部分を好きなドメインに書き換えてアクセスすることで、好きなドメインからスクリプトを読み込むことが可能になります。
   実装してみる  今回実装する脆弱なWebサーバーは、以下の機能を有しています。
 //&amp;lt;ホスト名&amp;gt;というようなアクセスでリダイレクトが可能  ex. http://vulnerable-server//example.com   正規化されたパスのコンテンツが返却される  ex. http://example.com/first/.. =&amp;gt; http://example.com/   相対パスでスクリプトの読み込みが行われている  ex. &amp;lt;script src=script.js&amp;gt;&amp;lt;/script&amp;gt;    Webサーバーの実装は以下の通りです。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package main import ( &amp;#34;net/http&amp;#34; &amp;#34;log&amp;#34; &amp;#34;path&amp;#34; &amp;#34;fmt&amp;#34; ) type VulnerableHandler map[string]http.</description>
    </item>
    
    <item>
      <title>イベントハンドラでの実体参照の扱い</title>
      <link>https://mute1997.github.io/post/2020-11-07-entity-reference-in-event-handler/</link>
      <pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2020-11-07-entity-reference-in-event-handler/</guid>
      <description>以下の記事を読んでいて気になったことがあるので調べてみた。
https://portswigger.net/web-security/cross-site-scripting/preventing#encode-data-on-output
気になったのは以下の部分。
1 2 3  Sometimes you&amp;#39;ll need to apply multiple layers of encoding, in the correct order. For example, to safely embed user input inside an event handler, you need to deal with both the JavaScript context and the HTML context. So you need to first Unicode-escape the input, and then HTML-encode it: &amp;lt;a href=&amp;#34;#&amp;#34; onclick=&amp;#34;x=&amp;#39;This string needs two layers of escaping&amp;#39;&amp;#34;&amp;gt;test&amp;lt;/a&amp;gt;   イベントハンドラにJavaScriptを書いている所にユーザーの入力を埋め込む場合は、unicodeエスケープをしてからHTMLエンコードする必要があると書いてある。
個人的にはunicodeエスケープだけではダメなのか気になったので実験してみた。
アラートを実行するために&#39;;alert(1);&#39;を入力したことを考える。</description>
    </item>
    
    <item>
      <title>DirtycowのPoCを読む</title>
      <link>https://mute1997.github.io/post/2018-08-11-how-dirtycow-work/</link>
      <pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/2018-08-11-how-dirtycow-work/</guid>
      <description>DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。
rootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC(https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c)についてまとめます。
   DirtyCowについて  DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。 CVEではCVE-2016-5195として管理されています。
https://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html
   前提知識など     mmap  mmapはファイルやデバイスをメモリにマッピングするためのものです。
readやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。
そのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。
&amp;ldquo;なるようです&amp;quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。
日本語で詳しく解説されている記事があったのでどうぞ。
man mmapしてでてくる情報を簡単にまとめます。 プロトタイプ宣言は次のようになっています。
1  void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);   addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。
lenにはマッピングするサイズを指定します。
protにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。
flagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。
fildesにはファイルディスクリプタを指定します。
offにはファイルのオフセットを指定します。
mmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include &amp;lt;stdio.</description>
    </item>
    
  </channel>
</rss>
