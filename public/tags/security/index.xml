<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>security on メモ帳</title>
    <link>https://mute1997.github.io/tags/security/</link>
    <description>Recent content in security on メモ帳</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://mute1997.github.io/tags/security/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Memory-Safety Challenge Considered Solved? An In-DepthExperience Report with All Rust CVEs</title>
      <link>https://mute1997.github.io/post/memory-safety-challenge-considered-solved/</link>
      <pubDate>Sat, 08 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/memory-safety-challenge-considered-solved/</guid>
      <description>ふとRustで書かれたソフトウェアでは絶対にメモリ系のバグが起こらないのか気になりました。 メモリ系のバグが起こらないとしたらファジングで脆弱性を見つけることは出来ないがパニックするパターンは発見できる？ その辺りがちょっと気になっていた所、この論文[1]を見つけたので読みました。 正確な翻訳ではなく、ちょっとしたまとめとただの感想です。
この論文ではRustに存在する脆弱性のリストを調査して, メモリ安全性を達成出来るのかどうかを調査している。 リストは以下の２つ。
Advisory-db
Trophy-cases
このリストを調査したところ、Rustによってuse-after-free, double-freeの問題を新たに引き起こしてしまう場合があるということを言っている。
今回はUse-After-Free, Double-Free辺りの問題を見てみる。
Use-After-Free コンストラクタにunsafeを使った場合にUse-After-Freeが発生するということを言ってる。
例として以下のコードを考える。
このコードでは、コンストラクタではポインタの引数をdereferenceして参照を返す。 しかし、関数の終了時にこの参照が開放されてしまうので、mainで参照するとUse-After-Freeが発生する。
fn test() -&amp;gt; Vec&amp;lt;u8&amp;gt; { let mut s = String::from(&amp;#34;lifetime_test&amp;#34;); let ptr = s.as_mut_ptr(); unsafe { let v = Vec::from_raw_parts(ptr, s.len(), s.len()); v } } fn main() { let v = test(); assert_eq!(&amp;#39;l&amp;#39; as u8, v[0]); /*fail*/ } Double-Free Double-Freeはいろいろ起こりうるシチュエーションはあるみたいだけど、とりあえず以下のコードを考える。 srcがfun1のスコープを抜けるときに開放され、mainのスコープを抜けるときにfooの開放をしようとしてdouble-freeが発生する。
impl Drop for Foo { fn drop(&amp;amp;mut self) { println!(&amp;#34;Dropping: {}&amp;#34;,self.s); } } struct Foo {s: String} /*fix2:struct Foo {s: mem::ManuallyDrop&amp;lt;String&amp;gt;}*/ fn fun2(mut src: &amp;amp;mut String) -&amp;gt; Foo { let s = unsafe{ String::from_raw_parts(src.</description>
    </item>
    
    <item>
      <title>preenyを利用したサーバーのファジング</title>
      <link>https://mute1997.github.io/post/fuzz-app-that-use-sockets/</link>
      <pubDate>Sat, 08 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/fuzz-app-that-use-sockets/</guid>
      <description>最近AFLを利用していろんなソフトウェアのファジングをしています。 AFLとは、テスト手法であるファジングの一種でgreybox-fuzzingに分類されるものです。 詳しい使い方や詳細は以下を参照してください。
https://github.com/google/AFL
このAFLでは標準入力、もしくは引数からファイルとして受け取り、処理をした後に即座に終了するというアプリケーションが期待されます。 nginxなどのWebサーバーはイベントループがあり、ソケットを利用するためにAFLをそのまま利用することが出来ません。
イベントループは自分で即座にbreakすることですぐに終了することが出来ますが、ソケットの問題はpreenyで解決出来ます。
preenyとは https://github.com/zardus/preeny
preenyとは、LD_PRELOADでライブラリ関数を上書きするものです。 いくつかモジュールがありますが、desockというものを利用することでsocket()、bind()、listen()、accept()あたりが上書きされるようです。 これを利用することで、ソケット操作はstdin、stdoutを読み書きするようになるので、AFLで利用することができます。
shadowsocksで試してみる nginxとかでやろうと思ったんですが同じことをやっている英語記事を書いている途中に見つけてしまったのでshadowsocksでやります。
shadowsocksは中国で開発されたプロキシツールです。 オリジナルは中国政府から削除を要請されたようで、今は以下のレポジトリで開発が進んでいます。
https://github.com/shadowsocks/shadowsocks-libev
イベントループを止める shadowsocksはlibevを使ってイベントループを処理しています。
server.cにエントリーポイントがあるのでここから読み進めていきます。 読み進めていくと, server_recv_cb()という関数で受信処理をしているようです。 この関数をラップして, この関数の終了時にイベントループを終わらせるようにします。
static void server_recv_once_cb(EV_P_ ev_io *w, int revents) { server_recv_cb(loop, w, revents); ev_break(EV_A_ EVBREAK_ONE); } static server_t * new_server(int fd, listen_ctx_t *listener) { ... ev_io_init(&amp;amp;server-&amp;gt;recv_ctx-&amp;gt;io, server_recv_once_cb, fd, EV_READ); ... } こうすることで, リクエストを１つ受け取ったら終了するようになりました。
afl-gccでコンパイルするように変更 src/Makefileを編集してgccと書いてあるところをafl-gccにしていきます。
... CC = afl-gcc ... コンパイルします。 コンパイル途中にInstrumented n locationsみたいな表示が出てきたらAFLを利用して, コンパイル出来ています。
$ make afl-cc 2.</description>
    </item>
    
    <item>
      <title>Dirtycowはどのように動くか</title>
      <link>https://mute1997.github.io/post/how-dirtycow-work/</link>
      <pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mute1997.github.io/post/how-dirtycow-work/</guid>
      <description>DirtyCowについて調べたので理解するのに必要となる前提知識と一緒にPoCについての説明をまとめておきます。
rootを取ったり、REHLで動くものがありますが今回は一番基本的な、権限のないファイルに書き込むPoC([https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c:title])についてまとめます。
DirtyCowについて DirtyCowはCopy on Writeの取り扱いにおいて競合状態が発生し、プライベートなメモリマッピングが破壊されるというものです。 CVEではCVE-2016-5195として管理されています。 [https://jvndb.jvn.jp/ja/contents/2016/JVNDB-2016-005596.html:title]
前提知識など mmap mmapはファイルやデバイスをメモリにマッピングするためのものです。
readやwriteを使うとカーネル空間からユーザープロセスへのコピーが発生しますが、mmapはマッピングしたアドレスを返すだけでユーザー空間へのコピーが発生しません。
そのためreadやwriteを使うよりも効率期にファイルの読み書きが可能になるようです。
&amp;ldquo;なるようです&amp;quot;と書いたのはどの場合においてもmmapのほうが早いわけではないからです。
日本語で詳しく解説されている記事があったのでどうぞ。
man mmapしてでてくる情報を簡単にまとめます。 プロトタイプ宣言は次のようになっています。
void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off); addrにはマッピングするアドレスを指定します。NULLを指定するとマッピングするアドレスをカーネルが決定してくれます。
lenにはマッピングするサイズを指定します。
protにはPROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONEを指定します。それぞれ、実行可能、読み書き可能、書き込み可能、アクセス不可能を表します。
flagsには、MAP_SHARED, MAP_PRIVATE, MAP_FIXEDが指定できます。MAP_PRIVATEが指定されるとCopy on Writeでファイルがマッピングされます。
fildesにはファイルディスクリプタを指定します。
offにはファイルのオフセットを指定します。
mmapを利用した簡単なファイルを読み込むをするサンプルを書いてみました。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt; int main(int argc, char *argv[]){ if (argc &amp;lt;= 1) { printf(&amp;#34;please specify filename\n&amp;#34;); return 1; } int fd = open(argv[1],O_RDONLY); if (fd &amp;lt; 0) { printf(&amp;#34;file not found\n&amp;#34;); return 1; } printf(&amp;#34;file discriptor: %d\n&amp;#34;, fd); struct stat st; fstat(fd, &amp;amp;st); printf(&amp;#34;file size: %ld\n&amp;#34;, st.</description>
    </item>
    
  </channel>
</rss>